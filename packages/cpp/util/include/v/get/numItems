#pragma once
#include <v/_/_>

#include "v/has"

#include <cstddef>

namespace VOLTISO_NAMESPACE::get {

template <class T>
  requires hasValue::NUM_ITEMS<T>
[[nodiscard]] constexpr decltype(auto) numItems(const T &t) noexcept {
	return t.NUM_ITEMS;
}

template <class T>
  requires hasFunction::NUM_ITEMS<T>
[[nodiscard]] constexpr decltype(auto) numItems(const T &t) noexcept {
	return t.NUM_ITEMS(); // quite exotic
}

// !

template <class T>
  requires(!has::NUM_ITEMS<T> && hasValue::numItems<T>)
[[nodiscard]] constexpr decltype(auto) numItems(const T &t) noexcept {
	return t.numItems;
}

template <class T>
  requires(!has::NUM_ITEMS<T> && hasFunction::numItems<T>)
[[nodiscard]] constexpr decltype(auto) numItems(const T &t) noexcept {
	return t.numItems();
}

// !

// for raw arrays
template <class T, std::size_t N>
[[nodiscard]] consteval std::size_t numItems(const T (&)[N]) noexcept {
	return N;
}

// !

// std compatibility
template <class T>
  requires(!has::NUM_ITEMS<T> && !has::numItems<T> && hasValue::size<T>)
[[nodiscard]] constexpr decltype(auto) numItems(const T &t) noexcept {
	return t.size;
}

// std compatibility
template <class T>
  requires(!has::NUM_ITEMS<T> && !has::numItems<T> && hasFunction::size<T>)
[[nodiscard]] constexpr decltype(auto) numItems(const T &t) noexcept {
	return t.size();
}

} // namespace VOLTISO_NAMESPACE::get
