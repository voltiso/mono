#pragma once
#include <v/_/_>

#include "v/_/memo.forward.hpp"

#include "v/any-function"
#include "v/array"
#include "v/dynamic-array"
#include "v/late-init"
#include "v/ref"
#include "v/sink"
#include "v/subject"

#include <cstddef>
#include <limits>

#include <v/ON>

namespace VOLTISO_NAMESPACE {
template <class Value, V::memo::NumDeps NUM_DEPS>
class Memo : private Subject<Value> {
	friend class EagerSubscription<Value>;
	using Base = Subject<Value>;

	using UpdateCallback = AnyFunction<Value()>; // todo: support `noexcept`
	UpdateCallback _updateCallback;

	using Deps = std::conditional_t<
	  NUM_DEPS == std::numeric_limits<memo::NumDeps>::max(),
	  DynamicArray<LateInit<Owned<Subscription>>>,
	  Array<LateInit<Owned<Subscription>>, NUM_DEPS>>;

	Deps _deps;
	bool _isDirty = true;

public:
	INLINE constexpr bool isDirty() const noexcept { return _isDirty; }

public:
	[[nodiscard]] INLINE constexpr Memo(
	  const std::array<Ref<sink::Base>, NUM_DEPS> &deps,
	  UpdateCallback &&updateCallback) noexcept(false) // throws OOM
	  requires(NUM_DEPS != std::numeric_limits<memo::NumDeps>::max())
	    : _updateCallback(std::move(updateCallback)) {
		static_assert(get::EXTENT<decltype(deps)> == NUM_DEPS);
		for (std::size_t i = 0; i < NUM_DEPS; ++i) {
			_deps[i].construct(
			  deps[i].target.createLazySubscription(
			    [this]() noexcept(noexcept(this->_maybeMakeDirty())) {
				    this->_maybeMakeDirty();
			    }));
		}
	}

	// public:
	// 	template <class... Args>
	// 	[[nodiscard]] constexpr auto createSubscription(Args &&...args) noexcept(
	// 	  noexcept(Base::createSubscription(std::forward<Args>(args)...))) {
	// 		return Base::createSubscription(std::forward<Args>(args)...);
	// 	}

private:
	INLINE void _maybeMakeDirty() noexcept(noexcept(Base::_notify())) {
		if (_isDirty) [[likely]] {
			return;
		}
		_isDirty = true;
		Base::_notify();
	}

private:
	INLINE constexpr void _maybeUpdate() noexcept(noexcept(_update())) {
		if (_isDirty) [[unlikely]] {
			_update();
		}
	}

	INLINE constexpr void _update() noexcept(
	  noexcept(_updateCallback()) &&
	  std::is_nothrow_move_constructible_v<Value>) {
		// pull up-to-date values from dependencies?
		// std::cout << "memo: call update callback" << std::endl;
		CHECK(_isDirty);
		auto newValue = _updateCallback();
		_isDirty = false;
		// if new value is the same as old, don't update
		// if constexpr (requires { newValue == Base::_value; }) {
		if (newValue == Base::_value) [[unlikely]] {
			return;
		}
		// }
		Base::_value = std::move(newValue);
	}

public:
	[[nodiscard]] INLINE constexpr const auto &
	value() noexcept(noexcept(_maybeUpdate()) && noexcept(Base::value())) {
		_maybeUpdate();
		return Base::value();
	}

	// also expose `.operator()` mapping to `.value()`
	[[nodiscard]] INLINE constexpr const auto &operator()() noexcept {
		return this->value();
	}

private:
	INLINE void
	_onNewEagerSubscription(EagerSubscription<Value> &eagerSubscription) noexcept(
	  noexcept(
	    noexcept(_maybeUpdate()) && noexcept(eagerSubscription._notify()))) {
		_maybeUpdate();
		eagerSubscription._notify(); // call the new subscription immediately
	}

public:
	using Base::createSubscription;
	using Base::map;
	using Base::sink;      // cast to Sink base-base should be safe?
	using Base::subscribe; // make sure it captures `this self&`
};
} // namespace VOLTISO_NAMESPACE

#include <v/OFF>
