#pragma once

// #include "v/Owned"
// #include "v/Shared"
#include "v/is_instantiated_from"
#include "v/is_trivially_relocatable"

#include <type_traits>
#include <utility>

#include <v/ON>

//

namespace VOLTISO_NAMESPACE {
/**
 * @brief Provides type-erasure for `Owned` and `Shared` smart pointers.
 *
 * Works with any magic pointer type that:
 *  - has `sizeof(void *)` size
 *  - can be safely bit_cast to `T*` (i.e. shared pointer must have T as first
 * in its control block)
 */
template <class Item = void> class Any {
private:
	using Deleter = void (*)(Item *&);

public:
	Item *const target = nullptr;

private:
	Deleter deleter;

public:
	~Any() {
		// deleter is nullptr if object is moved-from
		if (deleter) [[likely]] {
			deleter(const_cast<Item *&>(this->target));
		}
	}

public:
	// reference-semantics (empty Ref is forbidden)
	Any() = delete;

	// won't work with unique pointers (`Owned`)
	Any(const Any &) = delete;

	Any(Any &&other) : target(other.target), deleter(other.deleter) {
		NE(this, &other);
		other.deleter = nullptr;
	}

	template <class Other>
	  requires(!is_instantiated_from<Other, Any>)
	Any(Other &&other) {
		static_assert(sizeof(Other) == sizeof(this->target));
		auto &storage = (Other &)this->target;
		new (&storage) Other(std::move(other));
		deleter = [](auto &storage) {
			reinterpret_cast<Other &>(storage).~Other();
		};
	}

public:
	// assign to underlying value (reference semantics)
	template <class OtherItem>
	  requires(
	    std::is_assignable_v<Item &, OtherItem> &&
	    // Only check the second condition if OtherItem actually has operator*
	    (!(requires(OtherItem t) {
		    { *t };
	    }) ||
	     !std::is_assignable_v<Item &, decltype(*std::declval<OtherItem>())>))
	Any &operator=(OtherItem &&other) {
		item() = std::forward<OtherItem>(other);
		return *this;
	}

	template <
	  class TT = Item, std::enable_if_t<!std::is_same_v<TT, void>> * = nullptr>
	TT &item() const {
		CHECK(target);
		return *static_cast<Item *>(target);
	}

	Item *operator->() const { return target; }

	template <
	  class TT = Item, std::enable_if_t<!std::is_same_v<TT, void>> * = nullptr>
	TT &operator*() const {
		return item();
	}

	explicit operator bool() const { return target; }

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator TT &() const {
		return item();
	}

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator const TT &() const {
		return item();
	}

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator TT &&() const {
		return (Item &&)(**this);
	}

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator const TT &&() const {
		return (Item &&)(**this);
	}

public:
	[[nodiscard]] Any<const Item> &&freeze() && {
		return reinterpret_cast<Any<const Item> &&>(*this);
	}

	[[nodiscard]] const Any<const Item> &&freeze() const && {
		return reinterpret_cast<const Any<const Item> &&>(*this);
	}

	const Any<const Item> &frozen() const && {
		static_assert(false, "Ref::frozen() works only for lvalue references");
	}

	[[nodiscard]] Any<const Item> &frozen() & {
		return reinterpret_cast<Any<const Item> &>(*this);
	}

	[[nodiscard]] const Any<const Item> &frozen() const & {
		return reinterpret_cast<const Any<const Item> &>(*this);
	}
};

template <class T> constexpr bool is_trivially_relocatable<Any<T>> = true;
} // namespace VOLTISO_NAMESPACE

#include <v/OFF>
