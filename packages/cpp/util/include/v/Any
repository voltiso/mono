#pragma once

// #include "v/Owned"
// #include "v/Shared"
#include "v/is_instantiated_from"
#include "v/is_trivially_relocatable"

#include <type_traits>
#include <utility>

#include <v/ON>

//

namespace VOLTISO_NAMESPACE {
/**
 * @brief Provides type-erasure for `Owned` and `Shared` smart pointers.
 *
 * Works with any magic pointer type that:
 *  - has `sizeof(void *)` size
 *  - can be safely bit_cast to `T*` (i.e. shared pointer must have T as first
 * in its control block)
 */
template <class Item = void> class Any {
private:
	using Deleter = void (*)(Item *&);

public:
	Item *const target = nullptr; // const because public

private:
	VOLTISO_FORCE_INLINE constexpr auto &_target() & noexcept {
		return const_cast<Item *&>(target);
	}
	VOLTISO_FORCE_INLINE constexpr const auto &_target() const & noexcept {
		return target;
	}

private:
	Deleter deleter;

	// Storage<ref::Dynamic<Owned<int>>> storage;

public:
	~Any() {
		// deleter is nullptr if object is moved-from
		if (deleter) [[likely]] {
			deleter(this->_target());
		}
	}

public:
	// reference-semantics (empty Ref is forbidden)
	Any() = delete;

	// won't work with unique pointers (`Owned`)
	Any(const Any &) = delete;

	Any(Any &&other) {
		NE(this, &other);
		const_cast<Item *&>(target) = other.target;
		deleter = other.deleter;
		// other.pointer = nullptr;
		other.deleter = nullptr;
	}

	template <class Other>
	  requires(!is_instantiated_from<Other, Any>)
	Any(Other &&other) {
		static_assert(sizeof(Other) == sizeof(this->target));
		auto &storage = (Other &)this->target;
		new (&storage) Other(std::move(other));
		deleter = [](auto &storage) {
			reinterpret_cast<Other &>(storage).~Other();
		};
	}

	// template <
	//   class Other,
	//   class = std::enable_if_t<std::is_assignable_v<Item *&, Other *>>>
	// Any(Owned<Other> &&other) {
	// 	static_assert(sizeof(Owned<Other>) == sizeof(void *));
	// 	new (const_cast<Item **>(&this->target)) Owned<Other>(std::move(other));
	// 	this->deleter = [](void *p) {
	// 		using Pool = Pool<Other>;
	// 		using Handle = typename Pool::Handle;
	// 		auto &pool = Singleton<Pool>::instance();
	// 		pool.erase(Handle(p));
	// 	};
	// }

	// template <
	//   class Other,
	//   class = std::enable_if_t<std::is_assignable_v<Item *&, Other *>>>
	// Any(Shared<Other> &&other) {
	// 	const_cast<void *&>(target) = &other.item();

	// 	auto *controlBlock =
	// 	  reinterpret_cast<shared::_::ControlBlock<Other> *>(this->target);
	// 	static_assert(
	// 	  offsetof(shared::_::ControlBlock<Other>, item) == 0,
	// 	  "item must be the first member of ControlBlock");
	// 	++controlBlock->numReferences;

	// 	this->deleter = [](void *p) {
	// 		auto *controlBlock =
	// 		  reinterpret_cast<shared::_::ControlBlock<Other> *>(p);
	// 		controlBlock->dereference();
	// 	};
	// }

public:
	// assign to underlying value (reference semantics)
	template <class OtherItem>
	  requires(
	    std::is_assignable_v<Item &, OtherItem> &&
	    // Only check the second condition if OtherItem actually has operator*
	    (!(requires(OtherItem t) {
		    { *t };
	    }) ||
	     !std::is_assignable_v<Item &, decltype(*std::declval<OtherItem>())>))
	Any &operator=(OtherItem &&other) {
		item() = std::forward<OtherItem>(other);
		return *this;
	}

	template <
	  class TT = Item, std::enable_if_t<!std::is_same_v<TT, void>> * = nullptr>
	TT &item() const {
		// auto target = this->target();
		CHECK(target);
		return *static_cast<Item *>(target);
	}

	Item *operator->() const { return target; }

	template <
	  class TT = Item, std::enable_if_t<!std::is_same_v<TT, void>> * = nullptr>
	TT &operator*() const {
		return item();
	}

	explicit operator bool() const { return target; }

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator TT &() const {
		return item();
	}

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator const TT &() const {
		return item();
	}

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator TT &&() const {
		return (Item &&)(**this);
	}

	template <class TT = Item>
	  requires(std::is_same_v<TT, Item> && !std::is_same_v<Item, void>)
	operator const TT &&() const {
		return (Item &&)(**this);
	}

public:
	[[nodiscard]] Any<const Item> &&freeze() && {
		return reinterpret_cast<Any<const Item> &&>(*this);
	}

	[[nodiscard]] const Any<const Item> &&freeze() const && {
		return reinterpret_cast<const Any<const Item> &&>(*this);
	}

	const Any<const Item> &frozen() const && {
		static_assert(false, "Ref::frozen() works only for lvalue references");
	}

	[[nodiscard]] Any<const Item> &frozen() & {
		return reinterpret_cast<Any<const Item> &>(*this);
	}

	[[nodiscard]] const Any<const Item> &frozen() const & {
		return reinterpret_cast<const Any<const Item> &>(*this);
	}
};

template <class T> constexpr bool is_trivially_relocatable<Any<T>> = true;
} // namespace VOLTISO_NAMESPACE

#include <v/OFF>
