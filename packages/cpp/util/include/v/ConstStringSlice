#pragma once
#include <v/_/_>

#include "v/_/ConstStringSlice.forward.hpp"

#include "v/Extent"
#include "v/Slice"
#include "v/get/EXTENT"

#include <v/ON>

namespace VOLTISO_NAMESPACE {
template <Extent T_EXTENT>
class ConstStringSlice : public Slice<const char, T_EXTENT> {
	using Base = Slice<const char, T_EXTENT>;
	// using Base::Base;

public:
	template <class Other>
	  requires(!std::is_array_v<std::remove_reference_t<Other>>)
	constexpr ConstStringSlice(Other &&other)
	    : Base{std::forward<Other>(other)} {}

public:
	// create from raw array - static extent
	template <std::size_t N>
	  requires(
	    T_EXTENT != Extent::DYNAMIC && T_EXTENT != Extent::UNBOUND &&
	    N == T_EXTENT.value + 1)
	constexpr ConstStringSlice(const char (&chars)[N])
	    : Base{reinterpret_cast<const char (&)[T_EXTENT.value]>(chars)} {
		EQ(chars[T_EXTENT.value], '\0');
	}

	constexpr bool operator==(const ConstStringSlice &other) const {
		// todo: we could have traits `is_trivially_equal_comparable` and
		// `is_trivially_less_comparable` - and use memcmp
		// (or `binary` instead of `trivially`)
		// return items == other.items ||
		//        memcmp(items, other.items, sizeof(RawArray)) == 0;
		if (&this->items == &other.items) [[unlikely]] {
			return true; // assume a==a
		}

		for (size_t i = 0; i < T_EXTENT.value; ++i) {
			if (this->items[i] != other.items[i]) {
				return false;
			}
		}
		return true;
	}

	// for std?
	constexpr size_t size() const noexcept {
		NE(this->extent(), Extent::DYNAMIC);
		NE(this->extent(), Extent::UNBOUND);
		return this->extent();
	}
}; // class StringSlice

// deduction guide for raw arrays
template <size_t N>
ConstStringSlice(const char (&)[N]) -> ConstStringSlice<N - 1>;

// deduction guide for custom tuples
template <class TArray>
  requires(
    !std::is_array_v<TArray> &&
    std::is_same_v<
      std::remove_reference_t<decltype(std::declval<TArray>()[0])>, const char>)
ConstStringSlice(TArray &array) -> ConstStringSlice<get::EXTENT<TArray>>;

} // namespace VOLTISO_NAMESPACE

#include <v/OFF>
