#pragma once
#include <v/_/_>

#include "v/Pool"
#include "v/Storage"
#include "v/is_instantiated_from"
#include "v/is_trivially_relocatable"

#include <type_traits>

namespace VOLTISO_NAMESPACE {

template <class R, class... Args> class AnyFunction;

/**
 * type-erasure for callables
 * One-pointer storage is in-place (if trivially relocatable)
 */
template <class R, class... Args> class AnyFunction<R(Args...)> {
private:
	using Self = AnyFunction;
	using Storage = Storage<std::byte[sizeof(void *)]>;
	using Deleter = void (*)(Storage &);
	using Invoker = R (*)(Storage &, Args...);

	//   using RawFunction = R (&)(Args...);
	using RawPointer = R (*)(Args...);

	Storage storage;
	Deleter deleter = nullptr;
	Invoker invoker = nullptr;

public:
	AnyFunction() = delete;
	AnyFunction(const AnyFunction &) = delete;
	AnyFunction &operator=(const AnyFunction &) = delete;

	AnyFunction(AnyFunction &&other) noexcept {
		memcpy((void *)this, &other, sizeof(AnyFunction));
		other.deleter = nullptr;
	}

	~AnyFunction() {
		// speed-up raw pointer path
		if (deleter) [[unlikely]] {
			deleter(storage);
		}
	}

	// for HashTable
	bool operator==(const AnyFunction &other) const {
		static_assert(sizeof(storage) == sizeof(std::uintptr_t));
		// ! in some peculiar cases this could not be enough
		return std::bit_cast<std::uintptr_t>(storage) ==
		       std::bit_cast<std::uintptr_t>(other.storage);
		// return std::bit_cast<std::uintptr_t>(storage) ==
		//            std::bit_cast<std::uintptr_t>(other.storage) &&
		//        invoker == other.invoker && deleter == other.deleter;
		// return storage == other.storage && invoker == other.invoker &&
		//        deleter == other.deleter;
	}

	// for HashTable
	auto &key() const {
		return *reinterpret_cast<const std::uintptr_t *>(&this->storage);
	}

	__attribute__((always_inline)) // can't hurt?
  R operator()(Args... args) {
		return invoker(storage, std::forward<Args>(args)...); // always this path
	}

	// bind function pointer or stateless lambda
	template <
	  class TCallable,
	  std::enable_if_t<
	    // !is_instantiated_from<std::decay_t<TCallable>, Function> &&
	    std::is_convertible_v<std::decay_t<TCallable>, RawPointer>> * = nullptr>
	AnyFunction(TCallable &&f) {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
		new (&storage) RawPointer{std::forward<TCallable>(f)};
		invoker = [](Storage &storage, Args... args) -> R {
			return std::bit_cast<RawPointer>(storage)(std::forward<Args>(args)...);
		};
		static_assert(std::is_trivially_destructible_v<RawPointer>);
	}

	// bind small anything
	template <
	  class TCallable,
	  std::enable_if_t<
	    // !is_instantiated_from<std::decay_t<TCallable>, Function> &&
	    !std::is_convertible_v<std::decay_t<TCallable>, RawPointer> &&
	    (sizeof(std::decay_t<TCallable>) <= sizeof(storage))> * = nullptr>
	AnyFunction(TCallable &&f) {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
		static_assert(
		  is_trivially_relocatable<std::decay_t<TCallable>>,
		  "mark your type as trivially relocatable, or use createIndirect");
		using Callable = std::decay_t<TCallable>;
		new (&storage) Callable{std::forward<TCallable>(f)};
		invoker = [](Storage &storage, Args... args) -> R {
			return (*reinterpret_cast<Callable *>(&storage))(
			  std::forward<Args>(args)...);
		};
		if constexpr (!std::is_trivially_destructible_v<Callable>) {
			deleter = [](Storage &storage) {
				std::bit_cast<Callable>(storage).~Callable();
			};
		}
	}

	// static_assert(!is_instantiated_from<std::decay_t<decltype([] {})>,
	// Function>);

	// bind big anything
	template <
	  class TCallable,
	  std::enable_if_t<
	    // !is_instantiated_from<std::decay_t<TCallable>, Function> &&
	    !std::is_convertible_v<std::decay_t<TCallable>, RawPointer> &&
	    (sizeof(std::decay_t<TCallable>) > sizeof(storage))> * = nullptr>
	AnyFunction(TCallable &&f) : AnyFunction{std::forward<TCallable>(f), 0} {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
	}

	// explicit "big anything"
	template <class TCallable> static Self createIndirect(TCallable &&f) {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
		return Self{std::forward<TCallable>(f), 0};
	}

private:
	// "big anything" implementation
	template <class TCallable> AnyFunction(TCallable &&f, int) {
		using Callable = std::decay_t<TCallable>;
		using Pool = Pool<Callable>;
		using Handle = typename Pool::Handle;
		auto &pool = Singleton<Pool>::instance();
		auto handle = pool.insert(std::forward<TCallable>(f)).handle;
		new (&storage) Handle(handle);
		deleter = [](Storage &storage) {
			auto &pool = Singleton<Pool>::instance();
			pool.erase(std::bit_cast<Handle>(storage));
		};
		invoker = [](Storage &storage, Args... args) -> R {
			return (*std::bit_cast<Handle>(storage))(std::forward<Args>(args)...);
		};
	}

}; // class Function

template <class R, class... Args>
static constexpr auto is_trivially_relocatable<AnyFunction<R(Args...)>> = true;

} // namespace VOLTISO_NAMESPACE

// static_assert(!v::is_instantiated_from<std::decay_t<decltype([]{})>,
// v::Function>);

// static v::Function<void()> test = [] {};
