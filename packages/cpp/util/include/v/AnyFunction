#pragma once
#include <v/_/_>

#include "v/Pool"
#include "v/Storage"
#include "v/is_instantiated_from"
#include "v/is_trivially_relocatable"

#include <type_traits>

namespace VOLTISO_NAMESPACE {

template <class R, class... Args> class AnyFunction;

/**
 * type-erasure for callables
 * One-pointer storage is in-place (if trivially relocatable)
 */
template <class Return, class... Args> class AnyFunction<Return(Args...)> {
	using Self = AnyFunction;

private:
	using RawPointer = Return (*)(Args...);
	using Storage = Storage<RawPointer>; // ...or not raw pointer

	using Deleter = void (*)(Storage &);
	using Invoker = Return (*)(Storage &, Args...);

	Storage storage;
	Deleter deleter = nullptr;
	Invoker invoker = nullptr;

public:
	AnyFunction() = delete;
	AnyFunction(const AnyFunction &) = delete;
	AnyFunction &operator=(const AnyFunction &) = delete;

	AnyFunction(AnyFunction &&other) noexcept {
		memcpy((void *)this, &other, sizeof(AnyFunction));
		other.deleter = nullptr;
	}

	~AnyFunction() {
		// speed-up raw pointer path
		if (deleter) [[unlikely]] {
			deleter(storage);
		}
	}

	// for HashTable
	bool operator==(const AnyFunction &other) const {
		static_assert(sizeof(storage) == sizeof(std::uintptr_t));
		// ! in some peculiar cases this could not be enough?
		return storage.bytes == other.storage.bytes;
	}

	// for HashTable
	auto &key() const {
		return *reinterpret_cast<const std::uintptr_t *>(&this->storage);
	}

	__attribute__((always_inline)) // can't hurt?
	Return
	operator()(Args... args) {
		return invoker(storage, std::forward<Args>(args)...); // always this path
	}

	// bind function pointer or stateless lambda
	template <class TCallable>
	  requires(std::is_convertible_v<std::decay_t<TCallable>, RawPointer>)
	AnyFunction(TCallable &&f) {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
		new (&storage) RawPointer{std::forward<TCallable>(f)};
		invoker = [](Storage &storage, Args... args) -> Return {
			return storage.object()(std::forward<Args>(args)...);
		};
		static_assert(std::is_trivially_destructible_v<RawPointer>);
	}

	// bind small anything
	template <class TCallable>
	  requires(
	    !std::is_convertible_v<std::decay_t<TCallable>, RawPointer> &&
	    (sizeof(std::decay_t<TCallable>) <= sizeof(storage)))
	AnyFunction(TCallable &&f) {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
		static_assert(
		  is_trivially_relocatable<std::decay_t<TCallable>>,
		  "mark your type as trivially relocatable, or use createIndirect");
		using Callable = std::decay_t<TCallable>;
		new (&storage) Callable{std::forward<TCallable>(f)};
		invoker = [](Storage &storage, Args... args) -> Return {
			return (*reinterpret_cast<Callable *>(&storage))(
			  std::forward<Args>(args)...);
		};
		if constexpr (!std::is_trivially_destructible_v<Callable>) {
			deleter = [](Storage &storage) {
				std::bit_cast<Callable>(storage).~Callable();
			};
		}
	}

	// bind big anything
	template <class TCallable>
	  requires(
	    !std::is_convertible_v<std::decay_t<TCallable>, RawPointer> &&
	    (sizeof(std::decay_t<TCallable>) > sizeof(storage)))
	AnyFunction(TCallable &&f)
	    : AnyFunction{CreateIndirectTag{}, std::forward<TCallable>(f)} {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
	}

	// explicit "big anything"
	template <class TCallable> static Self createIndirect(TCallable &&f) {
		static_assert(!is_instantiated_from<std::decay_t<TCallable>, AnyFunction>);
		return Self{CreateIndirectTag{}, std::forward<TCallable>(f)};
	}

private:
	struct CreateIndirectTag {};
	// "big anything" implementation
	template <class TCallable> AnyFunction(CreateIndirectTag, TCallable &&f) {
		using Callable = std::decay_t<TCallable>;
		using Pool = Pool<Callable>;
		using Handle = typename Pool::Handle;
		auto &pool = Singleton<Pool>::instance();
		auto handle = pool.insert(std::forward<TCallable>(f)).handle;
		new (&storage) Handle(handle);
		deleter = [](Storage &storage) {
			auto &pool = Singleton<Pool>::instance();
			pool.erase(storage.template as<Handle>());
		};
		invoker = [](Storage &storage, Args... args) -> Return {
			return (*storage.template as<Handle>())(std::forward<Args>(args)...);
		};
	}

}; // class Function

template <class R, class... Args>
static constexpr auto is_trivially_relocatable<AnyFunction<R(Args...)>> = true;

} // namespace VOLTISO_NAMESPACE

// static_assert(!v::is_instantiated_from<std::decay_t<decltype([]{})>,
// v::Function>);

// static v::Function<void()> test = [] {};
