#pragma once
#include <v/_/_>

#include "v/is/instantiated-from"
#include "v/is/trivially-relocatable"
#include "v/pool"
#include "v/storage"

#include <type_traits>

#include <v/ON>

namespace VOLTISO_NAMESPACE {

template <class R, class... Args> class AnyFunction;

/**
 * type-erasure for callables
 * One-pointer storage is in-place (if trivially relocatable)
 */
template <class Return, class... Args> class AnyFunction<Return(Args...)> {
	using Self = AnyFunction;

private:
	using RawPointer = Return (*)(Args...);
	using Storage = Storage<RawPointer>; // ...or not raw pointer

	using Deleter = void (*)(Storage &);
	using Invoker = Return (*)(const Storage &, Args...);

	Storage storage;
	Deleter deleter = nullptr;
	Invoker invoker = nullptr;

public:
	AnyFunction() = delete;
	AnyFunction(const AnyFunction &) = delete;
	AnyFunction &operator=(const AnyFunction &) = delete;

	AnyFunction(AnyFunction &&other) noexcept {
		memcpy((void *)this, &other, sizeof(AnyFunction));
		other.deleter = nullptr;
	}

	~AnyFunction() {
		// speed-up raw pointer path
		if (deleter) [[unlikely]] {
			deleter(storage);
		}
	}

	// for HashTable
	bool operator==(const AnyFunction &other) const {
		static_assert(sizeof(storage) == sizeof(std::uintptr_t));
		// ! in some peculiar cases this could not be enough?
		return storage.bytes == other.storage.bytes;
	}

	// for HashTable
	INLINE auto &key() const {
		return *reinterpret_cast<const std::uintptr_t *>(&this->storage);
	}

	INLINE constexpr Return operator()(Args... args) const noexcept {
		return invoker(storage, std::forward<Args>(args)...); // always this path
	}

	// bind function pointer or stateless lambda
	template <class TCallable>
	  requires(std::is_convertible_v<std::decay_t<TCallable>, RawPointer>)
	AnyFunction(TCallable &&f) {
		_checkCallable<TCallable>();
		static_assert(!is::InstantiatedFrom<std::decay_t<TCallable>, AnyFunction>);
		new (&storage) RawPointer{std::forward<TCallable>(f)};
		invoker = [](const Storage &storage, Args... args) -> Return {
			return storage.object()(std::forward<Args>(args)...);
		};
		static_assert(std::is_trivially_destructible_v<RawPointer>);
	}

	// bind small anything
	template <class TCallable>
	  requires(
	    !std::is_convertible_v<std::decay_t<TCallable>, RawPointer> &&
	    (sizeof(std::decay_t<TCallable>) <= sizeof(storage)))
	AnyFunction(TCallable &&f) {
		_checkCallable<TCallable>();
		static_assert(!is::InstantiatedFrom<std::decay_t<TCallable>, AnyFunction>);
		static_assert(
		  is::TriviallyRelocatable<std::decay_t<TCallable>>,
		  "mark your type as trivially relocatable, or use createIndirect");
		using Callable = std::decay_t<TCallable>;
		new (&storage) Callable{std::forward<TCallable>(f)};
		invoker = [](const Storage &storage, Args... args) -> Return {
			return (*reinterpret_cast<const Callable *>(&storage))(
			  std::forward<Args>(args)...);
		};
		if constexpr (!std::is_trivially_destructible_v<Callable>) {
			deleter = [](Storage &storage) {
				std::bit_cast<Callable>(storage).~Callable();
			};
		}
	}

	// bind big anything
	template <class TCallable>
	  requires(
	    !std::is_convertible_v<std::decay_t<TCallable>, RawPointer> &&
	    (sizeof(std::decay_t<TCallable>) > sizeof(storage)))
	AnyFunction(TCallable &&f)
	    : AnyFunction{CreateIndirectTag{}, std::forward<TCallable>(f)} {
		_checkCallable<TCallable>();
		static_assert(!is::InstantiatedFrom<std::decay_t<TCallable>, AnyFunction>);
	}

	// explicit "big anything"
	template <class TCallable> static Self createIndirect(TCallable &&f) {
		_checkCallable<TCallable>();
		static_assert(!is::InstantiatedFrom<std::decay_t<TCallable>, AnyFunction>);
		return Self{CreateIndirectTag{}, std::forward<TCallable>(f)};
	}

private:
	struct CreateIndirectTag {};
	// "big anything" implementation
	template <class TCallable> AnyFunction(CreateIndirectTag, TCallable &&f) {
		using Callable = std::decay_t<TCallable>;
		using Pool = Pool<Callable>;
		using Handle = typename Pool::Handle;
		auto &pool = Singleton<Pool>::instance();
		auto handle = pool.insert(std::forward<TCallable>(f)).handle;
		new (&storage) Handle(handle);
		deleter = [](Storage &storage) {
			auto &pool = Singleton<Pool>::instance();
			pool.erase(storage.template as<Handle>());
		};
		invoker = [](const Storage &storage, Args... args) -> Return {
			return (*storage.template as<Handle>())(std::forward<Args>(args)...);
		};
	}

private:
	template <class TCallable>
	static INLINE consteval void _checkCallable() noexcept {
		using Callable = std::decay_t<TCallable>;
		static_assert(
		  requires(Callable f) { f(std::declval<Args>()...); },
		  "Callable must be invocable with Args");

		using ConstCallable = const Callable;

		// since for now we only support const operator(), check if input type
		// provides const-qualified operator()
		static_assert(
		  requires(ConstCallable f) { f(std::declval<Args>()...); },
		  "Callable must provide const-qualified operator()");

		// same goes for noexcept-ness
		// our resulting function is marked noexcept
		static_assert(
		  noexcept(std::declval<ConstCallable>()(std::declval<Args>()...)),
		  "mark your operator() as noexcept");
	}

}; // class Function

template <class R, class... Args>
static constexpr auto is::TriviallyRelocatable<AnyFunction<R(Args...)>> = true;

} // namespace VOLTISO_NAMESPACE

// static_assert(!v::is::InstantiatedFrom<std::decay_t<decltype([]{})>,
// v::Function>);

// static v::Function<void()> test = [] {};

#include <v/OFF>
