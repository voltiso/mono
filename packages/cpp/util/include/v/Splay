#pragma once
#include <v/_/_>

#include "v/Bst"
#include "v/DynamicArray"
#include "v/Entry"
#include "v/Object"
#include "v/concepts/Options"
#include "v/option/Pool"

#include <concepts>

#include <v/ON>

#ifndef VOLTISO_DEBUG_SPLAY
	#define VOLTISO_DEBUG_SPLAY VOLTISO_DEBUG
#endif

namespace VOLTISO_NAMESPACE::splay::_ {
struct AccessPathNode {
	Handle node;
	uint8_t childIndex;
};

inline ::std::ostream &
operator<<(::std::ostream &os, const AccessPathNode &node) {
	return os << "{node: " << node.node
	          << ", childIndex: " << (int)node.childIndex << "}";
}; // struct _

} // namespace VOLTISO_NAMESPACE::splay::_

//

namespace VOLTISO_NAMESPACE::splay {
// struct Defaults {
//   using Pool = void; // need to override
// };
// using DefaultOptions = Options<Defaults>;

//

template <class Options>
  requires concepts::Options<Options>
class Custom;

template <class Options> class ConstAccessor {
protected:
	using Custom = Custom<Options>;
	using Entry = Custom::Entry;
	using Key = Custom::Key;
	using Handle = Custom::Handle;
	using Pool = Custom::Pool;

public:
	const Handle &root;
	const Custom &splay;

protected:
	friend Custom;
	ConstAccessor(const Handle &root, const Custom &splay)
	    : root(root), splay(splay) {}

protected:
	auto &_root() { return const_cast<Handle &>(root); }
	auto &_accessPath() const { return const_cast<Custom &>(splay).accessPath; }
	auto &_bst() const { return const_cast<Custom &>(splay).bst; }
	auto &_pool() const { return const_cast<Pool &>(splay.pool); }

public:
	Handle lowerBound(const Key &searchAtLeast) {
		if (!root) [[unlikely]] {
			return Handle::INVALID;
		}
		// LOG(INFO) << "lb start";
		// LOG(INFO) << "null is " << Handle::INVALID;
		DCHECK(root);
		auto node = root;
		auto cand = Handle::INVALID;
		auto &accessPath = _accessPath();
		accessPath.clear();
		// LOG(INFO) << "lb: search " << searchAtLeast;
		while (node) {
			// LOG(INFO) << "lb: node " << node << " key "
			//           << getKey(splay.pool[node].item());

			if (getKey(splay.pool[node].item()) < searchAtLeast) {
				accessPath.push({node, 0});
				node = splay.pool[node]->children[0];
			} else {
				accessPath.push({node, 1});
				cand = node;
				node = splay.pool[node]->children[1];
			}
		}
		_splayLastAccessPath();
		return cand;
	}

public:
	Handle find(const Key &keyToFind) {
		// void find(const Handle &nodeToFind) {
		// LOG(INFO) << "find " << nodeToFind;
		// LOG(INFO) << *this;

		auto &root = this->_root();
		// DCHECK(root);

		if (!root) [[unlikely]] {
			return handle::INVALID;
		}

		// ! todo: likely? unlikely?
		if (keyToFind == getKey(splay.pool[root])) {
			return root;
		}

		auto current = root;
		auto &accessPath = _accessPath();
		// auto &key = getKey(splay.pool[nodeToFind].item());
		accessPath.clear();
		while (current) {
			auto &currentKey = getKey(splay.pool[current]);

			if (currentKey == keyToFind) [[unlikely]] {
				accessPath.maybeGrowAndPush({current, 0});
				break;
			}

			if (keyToFind < currentKey) {
				accessPath.maybeGrowAndPush({current, 0});
				current = splay.pool[current].children[0];
			} else {
				CHECK(
				  currentKey <
				  keyToFind); // TODO: make it DCHECK_LT, change logging library so
				              // that it does not require operator<<
				accessPath.maybeGrowAndPush({current, 1});
				current = splay.pool[current].children[1];
			}
		}
		// DCHECK(current) << "key not found " << keyToFind;
		this->_splayLastAccessPath();
		if (current) {
			EQ(current, root);
		}
		return current;
	}

public:
	Handle min() {
		auto &root = this->_root();
		auto &pool = this->_pool();
		auto &bst = this->_bst();

		auto x = root;

		// ! this was not correct - splay trees can have unbounded heights
		// // ! we use in-place array in order to be able to use this class in
		// // allocators
		// using Stack = DynamicArray<Handle>::template WithInPlaceOnly<32>;

		using Stack = DynamicArray<Handle>;

		Stack stack;
		stack.push(x);
		while (pool[x]->children[0]) {
			x = pool[x]->children[0];
			stack.push(x);
		}

		// _splayRight(stack);
		auto iNode = stack._numItems - 1;
		while (iNode >= 3) {
			auto &x1 = stack[iNode - 1].item();
			auto &x2 = stack[iNode - 2].item();
			auto &x3 = stack[iNode - 3].item();
			bst.rotateRight(x2);
			bst.rotateRight(x1);
			pool[x3]->children[0] = x;
			iNode -= 2;
		}

		if (iNode == 2) {
			auto &x1 = stack[iNode - 1].item();
			auto &x2 = stack[iNode - 2].item();
			bst.rotateRight(x2);
			bst.rotateRight(x1);
			// iNode -= 2;
		} else if (iNode == 1) {
			auto &x1 = stack[iNode - 1].item();
			bst.rotateRight(x1);
		}

		root = x;
		return x;
	}

protected:
	void _splayLastAccessPath() {
		// LOG(INFO) << "accessPath " << splay.accessPath;
		// LOG(INFO) << "BEFORE SPLAY" << "\n" << *this;
		GT(splay.accessPath.numItems(), 0);
		auto iNode = splay.accessPath.numItems() - 1;
		auto node = splay.accessPath[iNode].node;
		auto &bst = _bst();
		auto &pool = const_cast<Pool &>(splay.pool);
		while (iNode >= 3) {
			auto &node1 = splay.accessPath[iNode - 1];
			auto &node2 = splay.accessPath[iNode - 2];
			auto &node3 = splay.accessPath[iNode - 3];

			if (node2.childIndex) {
				if (node1.childIndex) {
					// zig-zig
					bst.rotateLeft(node2.node);
					bst.rotateLeft(node1.node);
				} else {
					// zig-zag
					pool[node2.node].children[1] = bst.rotateRight(node1.node);
					bst.rotateLeft(node2.node);
				}
			} else {
				if (node1.childIndex) {
					// zag-zig
					pool[node2.node].children[0] = bst.rotateLeft(node1.node);
					bst.rotateRight(node2.node);
				} else {
					// zag-zag
					bst.rotateRight(node2.node);
					bst.rotateRight(node1.node);
				}
			}
			pool[node3.node].children[node3.childIndex] = node;
			iNode -= 2;
		}

		if (iNode == 2) {
			auto &node1 = splay.accessPath[iNode - 1];
			auto &node2 = splay.accessPath[iNode - 2];

			if (node2.childIndex) {
				if (node1.childIndex) {
					// zig-zig
					bst.rotateLeft(node2.node);
					bst.rotateLeft(node1.node);
				} else {
					// zig-zag
					pool[node2.node].children[1] = bst.rotateRight(node1.node);
					bst.rotateLeft(node2.node);
				}
			} else {
				if (node1.childIndex) {
					// zag-zig
					pool[node2.node].children[0] = bst.rotateLeft(node1.node);
					bst.rotateRight(node2.node);
				} else {
					// zag-zag
					bst.rotateRight(node2.node);
					bst.rotateRight(node1.node);
				}
			}
			// iNode -= 2;
		} else if (iNode == 1) {
			auto &node1 = splay.accessPath[iNode - 1];
			if (node1.childIndex) {
				bst.rotateLeft(node1.node);
			} else {
				bst.rotateRight(node1.node);
			}
		}

		this->_root() = node;

		// LOG(INFO) << "AFTER SPLAY" << "\n" << *this;

		// return node;
	}
};

template <class Options> class Accessor : public ConstAccessor<Options> {
	using Base = ConstAccessor<Options>;
	using Custom = Base::Custom;
	using Entry = Base::Entry;
	using Handle = Base::Handle;
	using Pool = Base::Pool;

private:
	friend Custom;
	Accessor(Handle &root, Custom &splay) : ConstAccessor<Options>(root, splay) {}

public:
	Handle insert(const Entry &entry) { return insert<>(entry); }
	Handle insert(Entry &&entry) { return insert<>(std::move(entry)); }

	// template <class E,
	//           class = std::enable_if_t<std::is_same_v<Entry,
	//           std::decay_t<E>>>>
	template <class... Args> Handle insert(Args &&...args) {
		auto &pool = this->_pool();
		auto node = pool.insert(std::forward<Args>(args)...);
		link(node);
		// LOG(INFO) << "Splay::insert " << pool[node].item();
		return node;
	}

public:
	void unlink(const Handle &nodeToUnlink) {
		auto &pool = this->_pool();
		// LOG(INFO) << "BEFORE FIND\n" << *this;
		this->find(getKey(pool[nodeToUnlink].item()));
		// LOG(INFO) << "AFTER FIND\n" << *this;
		auto &root = this->_root();
		auto &splay = const_cast<Custom &>(this->splay);
		DCHECK_EQ(root, nodeToUnlink);
		if (!pool[nodeToUnlink]->children[0]) [[unlikely]] {
			root = pool[nodeToUnlink]->children[1];
		} else if (!pool[nodeToUnlink]->children[1]) [[unlikely]] {
			root = pool[nodeToUnlink]->children[0];
		} else [[likely]] {
			root = splay.merge(
			  splay.pool[nodeToUnlink]->children[0],
			  splay.pool[nodeToUnlink]->children[1]);
		}
		pool[nodeToUnlink]->children[0] = Handle::INVALID;
		pool[nodeToUnlink]->children[1] = Handle::INVALID;
	}

	void link(const Handle &nodeToLink) {
		auto &root = this->_root();
		auto &pool = this->_pool();
		auto &accessPath = this->_accessPath();

		if (!root) [[unlikely]] {
			root = nodeToLink;
			return;
		}

		auto &key = getKey(pool[nodeToLink]);

		auto current = root;
		accessPath.clear();
		while (current) {
			auto &currentKey = getKey(pool[current]);
			if (key < currentKey) {
				accessPath.maybeGrowAndPush({current, 0});
				if (!pool[current].children[0]) [[unlikely]] {
					pool[current].children[0] = nodeToLink;
					break;
				}
				current = pool[current].children[0];
			} else {
				// << "cannot insert duplicate key "; // << key;
				CHECK(currentKey < key);
				accessPath.maybeGrowAndPush({current, 1});
				if (!pool[current].children[1]) [[unlikely]] {
					pool[current].children[1] = nodeToLink;
					break;
				}
				current = pool[current].children[1];
			}
		}
		accessPath.maybeGrowAndPush({nodeToLink, 0});
		this->_splayLastAccessPath();
		EQ(root, nodeToLink);
	}

	Entry erase(const Handle &nodeToErase) {
		// LOG(INFO) << "Splay::erase " << nodeToErase;
		auto &pool = this->_pool();
		this->find(getKey(pool[nodeToErase].item()));
		const auto &n = nodeToErase;
		auto &root = this->_root();
		auto &splay = const_cast<Custom &>(this->splay);
		EQ(root, n);
		if (!pool[n]->children[0]) [[unlikely]] {
			root = pool[n]->children[1];
		} else if (!pool[n]->children[1]) [[unlikely]] {
			root = pool[n]->children[0];
		} else [[likely]] {
			root =
			  splay.merge(splay.pool[n]->children[0], splay.pool[n]->children[1]);
		}
		auto entry = getEntry(splay.pool[n].item());
		pool[n].erase();
		return entry;
	}
}; // class Accessor
} // namespace VOLTISO_NAMESPACE::splay

//

namespace std {
template <class Options>
ostream &operator<<(
  ostream &os,
  const VOLTISO_NAMESPACE::splay::ConstAccessor<Options> &accessor) {
	using Handle = typename VOLTISO_NAMESPACE::splay::Custom<Options>::Handle;
	static thread_local int indent = 0;
	auto key =
	  VOLTISO_NAMESPACE::getKey(accessor.splay.pool[accessor.root].item());
	key >>= 32; // !!!
	os << accessor.root << ", key " << key << ", numBytes "
	   << accessor.splay.pool[accessor.root]->entry.numBytes;
	++indent;
	if (accessor.root) {
		for (int i = 0; i < 2; i++) {
			const auto constChild =
			  Handle(accessor.splay.pool[accessor.root]->children[i].value);
			auto child = constChild;
			if (child) {
				os << "\n";
				for (int i = 0; i < indent; i++) {
					os << "\t";
				}
				os << (i ? "R" : "L") << ":" << accessor.splay(child);
			}
			DCHECK_EQ(constChild, child);
		}
	}
	--indent;
	return os;
}
} // namespace std

//

namespace VOLTISO_NAMESPACE::splay {
template <class Options>
  requires concepts::Options<Options>
class Custom
    : public Object<
        typename Options::template With<option::CustomTemplate<Custom>>> {
	using Base =
	  Object<typename Options::template With<option::CustomTemplate<Custom>>>;
	using Self = Base::Self;

public:
	using Pool = Options::template Get<option::Pool>;
	using Handle = typename Pool::Handle;
	// using Allocator = typename Pool::Allocator;
	using Node = typename Pool::Item;
	using Entry = GetEntry<Node>;
	using Key = GetKey<Entry>; // may be implicit

	static_assert(std::equality_comparable<Key>);

	using ConstAccessor = ConstAccessor<Options>;
	using Accessor = Accessor<Options>;
	friend ConstAccessor;
	friend Accessor;

	static_assert(!std::is_same_v<Entry, void>);

private:
	// using DynamicArray = DynamicArray<int>::Allocator_<Allocator>;

	using AccessPathNode = _::AccessPathNode;
	// using AccessPathNode = _::template AccessPathNode<Final, Parameters>;

	// ! we use in-place array in order to be able to use this class in
	// allocators
	using AccessPath = DynamicArray<AccessPathNode>::template WithInPlaceOnly<32>;
	// using AccessPath = DynamicArray::template Item_<AccessPathNode>;
	AccessPath accessPath;

public:
	const Pool &pool; // const-cast when needed

private:
	Bst<Pool> bst;

private:
	auto &_pool() { return const_cast<Pool &>(pool); }

public:
	Custom(Pool &pool) : pool(pool), bst(pool) {}
	// Splay(Self&&) = default;

public:
	// assumes rootA < rootB
	Handle merge(Handle rootA, Handle rootB) {
		auto &pool = _pool();
		rootB = (*this)(rootB).min();
		CHECK(!pool[rootB]->children[0]);
		pool[rootB]->children[0] = rootA;
		return rootB;
	}

public:
	ConstAccessor operator()(Handle &root) const {
		return ConstAccessor(root, *this);
	}
	Accessor operator()(Handle &root) { return Accessor(root, *this); }
}; // class Custom
} // namespace VOLTISO_NAMESPACE::splay

// VOLTISO_OBJECT_FINAL(splay)

//

namespace VOLTISO_NAMESPACE {
template <class Pool>
class Splay : public splay::Custom<
                Options<option::Pool<Pool>, option::Self<Splay<Pool>>>> {
	// using Base =
	//   splay::Custom<Options<option::Pool<Pool>, option::Self<Splay<Pool>>>>;
};
} // namespace VOLTISO_NAMESPACE

#include <v/OFF>
