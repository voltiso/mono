#pragma once

#include "v/AnyFunction"
#include "v/HashSet"
#include "v/Owned"
#include "v/Retainer"
#include "v/context"
#include "v/is_trivially_relocatable"

#include <utility>

namespace VOLTISO_NAMESPACE {

// Forward declaration
template <class Value> class Subject;

namespace subject::_ {
template <class Value> using Callback = AnyFunction<void(const Value &)>;
} // namespace subject::_

namespace subject {
template <class Value> class Subscription {
public:
  using Callback = subject::_::Callback<Value>;
  using Subject = Subject<Value>;

private:
  friend Subject;
  Subject *subject = nullptr;
  Callback callback;

  static_assert(is_trivially_relocatable<Subject *>);
  static_assert(is_trivially_relocatable<Callback>);

public:
  Subscription(Subject &subject, Callback &&callback)
      : callback(std::move(callback)) {
    this->subject = &subject;
    this->subject->subscriptions.insert(*this);
  }

  ~Subscription() {
    // speed-up fast-path (e.g. move construction)
    if (subject) [[unlikely]]
      subject->subscriptions.erase(*this);
  }

  // Non-copyable
  Subscription(const Subscription &) = delete;
  Subscription &operator=(const Subscription &) = delete;

  // Movable
  Subscription(Subscription &&other) noexcept
      : subject(other.subject), callback(std::move(other.callback)) {
    other.subject = nullptr;
  }

private:
  friend Subject;
  void update(const Value &value) { callback(value); }

  // Subscription &operator=(Subscription &&other) noexcept {
  //   DCHECK_NE(this, &other);
  //   if (implementation) [[likely]] {
  //     implementation->listeners.erase(callback);
  //   }
  //   callback = other.callback;
  //   implementation = other.implementation;
  //   other.implementation = nullptr;
  //   return *this;
  // }
}; // class Subscription
} // namespace subject

template <class Value>
constexpr auto is_trivially_relocatable<subject::Subscription<Value>> = true;

template <class Value> class Subject {
public:
  using Callback = subject::_::Callback<Value>;
  using Subscription = subject::Subscription<Value>;

public:
  // Owned<subject::_::Implementation<T>> implementation;
  const Value value; // = T{};

private:
  auto &_value() { return const_cast<Value &>(this->value); }

private:
  using SubscriptionRef = Owned<subject::Subscription<Value>>;
  using SubscriptionRefWeak = typename SubscriptionRef::Weak;

  friend Subscription;
  HashSet<Subscription &> subscriptions;

public:
  ~Subject() {
    for (auto &subscription : subscriptions) {
      // subscription.unsubscribe();
      subscription.subject = nullptr;
    }
  }

  // Subject() = default;
  template <class V,
            std::enable_if_t<std::is_convertible_v<V &&, Value>> * = nullptr>
  Subject(V &&value) : value{std::forward<V>(value)} {}
  Subject(const Value &value) : value{value} {}
  Subject(Value &&value) : value{std::move(value)} {}

  template <class U> Subject &operator=(U &&value) {
    if constexpr (requires(const Value &lhs, U &&rhs) { lhs == rhs; })
      if (this->value == value) [[unlikely]]
        return *this;
    this->_value() = std::forward<U>(value);
    for (auto &subscription : this->subscriptions) {
      subscription.update(this->value);
    }
    return *this;
  }

  Subject &operator=(const Value &value) { return this->operator= <>(value); }
  Subject &operator=(Value &&value) {
    return this->operator= <>(std::move(value));
  }

private:
  template <class Listener>
  SubscriptionRef createSubscription(Listener &&listener) {
    return SubscriptionRef::create(*this, std::forward<Listener>(listener));
  }

public:
  // subscribe to future updates (does not call the callback with current value
  // until it changes)
  template <class Callback> void subscribe(Callback &&callback) {
    context::get<Retainer>().retain(
        createSubscription(std::forward<Callback>(callback)));
  }

  // immediately call the callback, and subscribe to future updates
  template <class Callback> void getAndSubscribe(Callback &&callback) {
    auto subscription = createSubscription(std::forward<Callback>(callback));
    subscription->update(this->value);
    context::get<Retainer>().retain(std::move(subscription));
  }
};

} // namespace VOLTISO_NAMESPACE
