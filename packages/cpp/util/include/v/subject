#pragma once

#include "v/any-function"
#include "v/context"
#include "v/hash-set"
#include "v/is/trivially-relocatable"
#include "v/owned"
#include "v/retainer"

#include <utility>

namespace VOLTISO_NAMESPACE {

// Forward declaration
template <class Value> class Subject;

namespace subject {
template <class Value> class Sink;
template <class Value> class Subscription;
template <class Value> using Callback = AnyFunction<void(const Value &)>;
} // namespace subject

// !

namespace subject {
template <class Value> class Subscription {
public:
	using Callback = Callback<Value>;
	using Sink = Sink<Value>;
	using Subject = Subject<Value>;

private:
	friend Sink;
	Sink *_pSink = nullptr;
	Callback _callback;

	static_assert(is::TriviallyRelocatable<Sink *>);
	static_assert(is::TriviallyRelocatable<Callback>);

public:
	Subscription(Sink &sink, Callback &&callback)
	    : _callback(std::move(callback)) {
		this->_pSink = &sink;
		this->_pSink->subscriptions.insert(*this);
	}

	~Subscription() {
		// speed-up fast-path (e.g. move construction)
		if (_pSink) [[unlikely]] {
			_pSink->subscriptions.erase(*this);
		}
	}

	// Non-copyable
	Subscription(const Subscription &) = delete;
	Subscription &operator=(const Subscription &) = delete;

	// Movable
	Subscription(Subscription &&other) noexcept
	    : _pSink(other._pSink), _callback(std::move(other._callback)) {
		other._pSink = nullptr;
	}

private:
	friend Subject;
	void _update(const Value &value) { _callback(value); }
}; // class Subscription
} // namespace subject

template <class Value>
constexpr auto is::TriviallyRelocatable<subject::Subscription<Value>> = true;

// !

namespace subject {
// base of Subject<Value>
// value is stored here in Sink (sic!)
template <class Value> class Sink {
	using Subscription = subject::Subscription<Value>;

protected:
	Value _value; // = T{};

public:
	const Value &value() const { return this->_value; }

protected:
	friend Subscription;
	HashSet<Subscription &> subscriptions;

public:
	~Sink() {
		for (auto &subscription : subscriptions) {
			// subscription.unsubscribe();
			subscription._pSink = nullptr;
		}
	}

public:
	template <class... Args>
	Sink(Args &&...args) : _value(std::forward<Args>(args)...) {}

private:
	template <class Listener>
	Owned<Subscription> createSubscription(Listener &&listener) {
		return Owned<Subscription>::create(*this, std::forward<Listener>(listener));
	}

public:
	// subscribe to future updates (does not call the callback with current
	// value until it changes)
	template <class Callback> void subscribe(Callback &&callback) {
		context::get<Retainer>().retain(
		  createSubscription(std::forward<Callback>(callback)));
	}

public:
	// immediately call the callback, and subscribe to future updates
	template <class Callback> void getAndSubscribe(Callback &&callback) {
		auto subscription = createSubscription(std::forward<Callback>(callback));
		subscription->update(this->_value);
		context::get<Retainer>().retain(std::move(subscription));
	}
};
} // namespace subject

template <class Value> class Subject : public subject::Sink<Value> {
	using Base = subject::Sink<Value>;
	using Sink = subject::Sink<Value>;

public:
	template <class... Args>
	Subject(Args &&...args) : Base(std::forward<Args>(args)...) {}

	Sink &sink() { return *this; }
	const Sink &sink() const { return *this; }

	template <class U> Subject &operator=(U &&value) {
		if constexpr (requires(const Value &lhs, U &&rhs) { lhs == rhs; }) {
			if (this->_value == value) [[unlikely]] {
				return *this;
			}
		}
		this->_value = std::forward<U>(value);
		for (auto &subscription : this->subscriptions) {
			subscription._update(this->_value);
		}
		return *this;
	}

	Subject &operator=(const Value &value) { return this->operator= <>(value); }
	Subject &operator=(Value &&value) {
		return this->operator= <>(std::move(value));
	}
};

} // namespace VOLTISO_NAMESPACE
