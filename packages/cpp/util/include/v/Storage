#pragma once
#include <v/_/_>

#include "v/_/Array.hpp"
#include "v/is_trivially_relocatable"

// #include "glog/logging.h"

#include <cstddef>
#include <initializer_list>

namespace VOLTISO_NAMESPACE::storage {
// To replace `std::aligned_storage`
// https://stackoverflow.com/a/71828512/1123898
template <size_t _SIZE, size_t ALIGN> struct Custom {
	static constexpr size_t SIZE = _SIZE;
	alignas(ALIGN) Array<std::byte, SIZE> data;
};
} // namespace VOLTISO_NAMESPACE::storage

namespace VOLTISO_NAMESPACE {
// To replace `std::aligned_storage`
// https://stackoverflow.com/a/71828512/1123898
// ⚠️ Remember to call `.destroy()` if you constructed something
template <class _Item> struct Storage {
	using Item = _Item;

	alignas(Item) Array<std::byte, sizeof(Item)> bytes; // !!!!!!

	auto &item() { return *reinterpret_cast<Item *>(&bytes[0]); }
	auto &item() const { return *reinterpret_cast<const Item *>(&bytes[0]); }

	Storage() = default;

	Storage(std::initializer_list<std::byte> init) : bytes(init) {
		// LOG(INFO) << "Storage(std::initializer_list<std::byte>)";
	}

	Storage(const Storage &other) =
	  delete; // we do not know if object is constructed
	Storage &operator=(const Storage &other) =
	  delete; // we do not know if object is constructed

	// bitwise move for trivially relocatable underlying type
	template <
	  class TItem = Item,
	  std::enable_if_t<is_trivially_relocatable<TItem>> * = nullptr>
	Storage(Storage &&other) {
		memcpy(&this->bytes, &other.bytes, sizeof(Item));
	}

	// bitwise move for trivially relocatable underlying type
	template <
	  class TItem = Item,
	  std::enable_if_t<is_trivially_relocatable<TItem>> * = nullptr>
	Storage &operator=(Storage &&other) {
		memcpy(&this->bytes, &other.bytes, sizeof(Item));
		return *this;
	}

	// bitwise compare
	bool operator==(const Storage &other) const {
		return memcmp(this, &other, sizeof(Storage)) == 0;
	}

	bool operator<(const Storage &other) const {
		return memcmp(this, &other, sizeof(Storage)) < 0;
	}

	// ⚠️ Remember to call `.destroy()` if you constructed
	// something
	template <class... Args> void construct(Args &&...args) {
		new (&bytes) Item{std::forward<Args>(args)...};
	}

	// ⚠️ Remember to call `.destroy()` if you constructed something
	void destroy() { item().~Item(); }
};
} // namespace VOLTISO_NAMESPACE
