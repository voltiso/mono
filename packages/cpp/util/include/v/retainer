#pragma once

#include "v/div-ceil"
#include "v/dynamic-array"
#include "v/is/trivially-relocatable"

namespace VOLTISO_NAMESPACE {

class Retainer {
private:
	struct alignas(std::max_align_t) TStorage {};
	static_assert(sizeof(TStorage) == alignof(std::max_align_t));

	using Data = DynamicArray<TStorage>;
	Data data;

	using Deleter = void (*)(void *);

	struct Item {
		Data::Handle offset;
		Deleter deleter;
	};
	DynamicArray<Item> items;

public:
	Retainer() = default;

	Retainer(const Retainer &) = delete;
	Retainer &operator=(const Retainer &) = delete;

public:
	// accept only r-value references
	template <class T, std::enable_if_t<!std::is_reference_v<T>> * = nullptr>
	void retain(T &&t) {
		static_assert(is::TriviallyRelocatable<T>);
		auto numNewStorageItems = divCeil(sizeof(T), sizeof(TStorage));
		data.setNumSlotsAtLeast(data.numItems() + numNewStorageItems);
		auto memory = &*data.end();
		auto prevNumStorageItems = data.numItems();
		data.setNumItems(data.numItems() + numNewStorageItems);
		new (memory) T(std::move(t));
		items.maybeGrowAndPush(
		  Item{
		    .offset = Data::Handle(prevNumStorageItems),
		    .deleter = [](void *memory) { static_cast<T *>(memory)->~T(); }});
	}

	~Retainer() {
		for (auto &item : items) {
			item.deleter(&data[item.offset]);
		}
	}
};

} // namespace VOLTISO_NAMESPACE
