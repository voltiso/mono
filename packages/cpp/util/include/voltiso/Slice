#pragma once
#include <voltiso/_>

#include "voltiso/ConstStringSlice.forward.hpp"

#include <cstddef>
#include <ostream>
#include <string_view>
#include <tuple>
#include <type_traits>

// static_assert(sizeof(std::span<int, 2>) == sizeof(int *));
// static_assert(sizeof(std::span<int>) == sizeof(int *) +
// sizeof(std::ptrdiff_t));

namespace VOLTISO_NAMESPACE {
// SHAPE is e.g. `int[][2][3]`
template <typename _SHAPE>
  requires std::is_array_v<_SHAPE>
class Slice {
public:
  using SHAPE = _SHAPE;
  static_assert(!std::is_reference_v<SHAPE>); // already implied by is_array_v?
  // static_assert(!std::is_const_v<RawArray>);

  using INNER_SHAPE = std::remove_extent_t<SHAPE>;
  static constexpr auto EXTENT = std::extent_v<SHAPE>;

public:
  // ! valid only if elements are packed (not strided apart)
  using Items = SHAPE;

  using Scalar = std::remove_all_extents_t<SHAPE>;

public:
  Items &items;

  // implicit - free to cast to a Slice
  Slice(SHAPE &items) : items(items) {}
  // ArrayView(Item (&items)[]) : items(items) {}

  Slice(const Slice &) = default;

  Slice &operator=(const Slice &) = delete; // ref semantics

  // Slice(const Slice &other) : items(other.items) {
  //   static_assert(EXTENT == 3);
  //   //
  // }

  // ! explicit - raw arrays don't handle comparison nicely
  explicit operator Items &() const { return items; }

  // todo: for md arrays this should return new inner Slice
  auto &operator[](size_t i) {
    static_assert(EXTENT > 0);
    return items[i];
  }

  auto &operator[](size_t i) const {
    static_assert(EXTENT > 0);
    return items[i];
  }

  template <size_t START, size_t END> [[nodiscard]] auto slice() const {
    static_assert(START < END && END <= EXTENT);
    using NewRawArray = INNER_SHAPE[END - START];
    auto slice = reinterpret_cast<NewRawArray *>(&items[START]);
    return Slice<NewRawArray>(*slice);
  }

  constexpr operator std::string_view() const noexcept
    requires std::is_same_v<INNER_SHAPE, char> ||
             std::is_same_v<INNER_SHAPE, const char>
  {
    return std::string_view(items, EXTENT);
  }
}; // class Slice

// deduction guide for raw arrays
template <class Item, size_t NUM_ITEMS>
// requires std::is_array_v<Item[NUM_ITEMS]> // redundant
Slice(Item (&array)[NUM_ITEMS]) -> Slice<Item[NUM_ITEMS]>;

// deduction guide for custom tuples
template <class TArray>
  requires(!std::is_array_v<TArray> &&
           requires {
             std::tuple_size_v<TArray>; // does not work?
             std::remove_reference_t<decltype(std::declval<TArray>()[0])>();
           })
Slice(TArray &array) -> Slice<std::remove_reference_t<
    decltype(array[0])>[std::tuple_size<TArray>::value]>;

//

// if both sides are convertible to ConstStringSlice, compare this way
template <class A, class B>
[[nodiscard]] inline constexpr auto operator==(const A &a, const B &b)
  requires requires {
    ConstStringSlice(a);
    ConstStringSlice(b);
  }
{
  auto sliceA = ConstStringSlice(a);
  auto sliceB = ConstStringSlice(b);
  static_assert(sliceA.EXTENT == sliceB.EXTENT, "String sizes mismatch");
  return std::equal(sliceA.items, sliceA.items + sliceA.EXTENT, sliceB.items);
}

// if both sides are convertible to Slice, compare this way
template <class A, class B>
[[nodiscard]] inline constexpr auto operator==(const A &a, const B &b)
  requires requires {
    Slice(a);
    Slice(b);
  } && (!(requires { ConstStringSlice(a); }) ||
        !(requires { ConstStringSlice(b); }))
{
  // int aa = ConstStringSlice(a);
  // static_assert(requires { ConstStringSlice(a); });
  auto sliceA = Slice(a);
  auto sliceB = Slice(b);
  // if constexpr (std::is_same_v<A, v::Array<int, 3>>) {
  //   // int x = sliceA;
  //   static_assert(sliceA.EXTENT == 3);
  // }
  // int aa = sliceB;
  static_assert(sliceA.EXTENT == sliceB.EXTENT, "Array sizes mismatch");
  return std::equal(sliceA.items, sliceA.items + sliceA.EXTENT, sliceB.items);
}

template <class RawArray>
std::ostream &operator<<(std::ostream &os, const Slice<RawArray> &slice) {
  os << '[';
  for (size_t i = 0; i < slice.EXTENT; i++) {
    if (i > 0) {
      os << ", ";
    }
    os << slice.items[i];
  }
  return os << "]";
} // operator<<
} // namespace VOLTISO_NAMESPACE
