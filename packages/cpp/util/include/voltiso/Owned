#pragma once
#include <voltiso/_>

#include "voltiso/Object"
#include "voltiso/Pool"
#include "voltiso/getHash"
#include "voltiso/getParameter/Type"
#include "voltiso/getParameter/VALUE"
#include "voltiso/is_trivially_relocatable"
#include "voltiso/parameter"

namespace VOLTISO_NAMESPACE::owned {
template <class Final, class Parameters> class Custom;
template <class Parameters> class Final;
} // namespace VOLTISO_NAMESPACE::owned

namespace VOLTISO_NAMESPACE {
template <class Parameters>
static constexpr auto is_trivially_relocatable<owned::Final<Parameters>> = true;

template <class Item>
using Owned = owned::Final<std::tuple<parameter::Item<Item>>>;

template <class Parameters>
std::size_t getHash(const VOLTISO_NAMESPACE::owned::Final<Parameters> &owned) {
  return getHash(&owned.item());
}
} // namespace VOLTISO_NAMESPACE

namespace VOLTISO_NAMESPACE::owned {

template <class Final, class Parameters> class Custom : public Object<Final> {
  using Item = getParameter::Type<parameter::Item, Parameters>;
  static_assert(!std::is_reference_v<Item>,
                "you probably don't want Owned<Item&>");

  // static_assert(!std::is_class_v<Item> || std::is_final_v<Item>);

  using CanonicalItem = std::remove_cv_t<Item>;
  using Pool = Pool<CanonicalItem>;
  static constexpr bool WEAK = getParameter::VALUE<parameter::WEAK, Parameters>;

public:
  template <class... Args> static Final create(Args &&...args) {
    return Final(pool().insert(std::forward<Args>(args)...), nullptr);
  }

  static Final create(const Item &item) {
    return Final(pool().insert(item), nullptr);
  }

  // static Final create(Item &&item) {
  //   Final self;
  //   self._item = pool().insert(std::move(item));
  //   return self;
  // }

  ~Custom() {
    static_assert(std::is_final_v<Final>); // need to test somewhere
    if constexpr (!WEAK)
      // TODO: likely/unlikely?
      // [[unlikely]] speeds-up move-out path
      // Moving-out should be the only case when this is triggered,
      //   because Owned is reference-style.
      if (this->_item) [[unlikely]] {
        // std::cout << "erase " << this->_item << std::endl;
        pool().erase(this->_item);
        // pool()[this->_item].erase();
      }
  }

  // public: Custom() = default; // convenient, but runtime-bug-prone

private:
  // @internal
  template <class Item>
  Custom(Item &&item, void *_unusedTag) : _item(std::forward<Item>(item)) {
    // std::cout << "create " << _item << std::endl;
  }

public:
  Custom() = delete;

  template <bool W = WEAK, std::enable_if_t<!W> * = nullptr>
  Custom(const Custom &) = delete;

  // template <bool W = WEAK, std::enable_if_t<W> * = nullptr>
  // Custom(const Custom &) = default;

  // copy constructor (for weak)
  template <class OtherFinal, class OtherParameters, bool W = WEAK,
            std::enable_if_t<
                W && std::is_assignable_v<
                         Item *&, typename getParameter::Type<
                                      parameter::Item, OtherParameters> *>> * =
                nullptr>
  Custom(const Custom<OtherFinal, OtherParameters> &other)
      : _item(other._item) {}

  // ! disable assignments - this should work like a reference, not a
  // ! pointer
  // // copy assignment (for weak)
  // template <class OtherFinal, class OtherParameters, bool W = WEAK,
  //           std::enable_if_t<
  //               W && std::is_assignable_v<
  //                        Item *&, typename getParameter::Type<
  //                                     parameter::Item, OtherParameters> *>> *
  //                                     =
  //               nullptr>
  // Custom &operator=(const Custom<OtherFinal, OtherParameters> &other) {
  //   this->_item = other._item;
  //   return *this;
  // }

  // ! disable assignments - this should work like a reference, not a
  // ! pointer
  // // move assignment (weak -> weak)
  // template <class OtherFinal, class OtherParameters,
  //           std::enable_if_t<
  //               WEAK && getParameter::VALUE<parameter::WEAK, OtherParameters>
  //               && std::is_assignable_v<
  //                   Item *&, typename getParameter::Type<parameter::Item,
  //                                                        OtherParameters> *>>
  //               * = nullptr>
  // Custom &operator=(Custom<OtherFinal, OtherParameters> &&other) {
  //   this->_item = other._item;
  //   return *this;
  // }

  template <class OtherFinal, class OtherParameters> friend class Custom;

  // move constructor (not for weak)
  template <bool W = WEAK, std::enable_if_t<!W> * = nullptr>
  Custom(Custom &&other) noexcept : _item(other._item) {
    other._item = Pool::Handle::INVALID;
    // std::cout << other._item.value << std::endl;
  }

  // ! disable move-assignments - this should work like a reference, not a
  // pointer
  // // move assignment (not for weak)
  // template <bool W = WEAK, std::enable_if_t<!W> * = nullptr>
  // Custom &operator=(Custom &&other) noexcept {
  //   if (this->_item) [[likely]]
  //     pool().erase(this->_item);
  //   // pool()[this->_item].erase();
  //   this->_item = other._item;
  //   other._item = Pool::Handle::INVALID;
  //   return *this;
  // }

  Custom &operator=(const Custom &) = delete;

public:
  // assign to underlying value
  template <class OtherItem>
    requires(
        std::is_assignable_v<Item &, OtherItem> &&
        // Only check the second condition if OtherItem actually has operator*
        (!(requires(OtherItem t) {
          { *t };
        }) ||
         !std::is_assignable_v<Item &, decltype(*std::declval<OtherItem>())>))
  Custom &operator=(OtherItem &&other) {
    pool()[this->_item].item() = std::forward<OtherItem>(other);
    return *this;
  }

  // Item &item() { return pool()[_item].item(); }
  // const Item &item() const { return pool()[_item].item(); }

public:
  Item &item() const {
    return *_item;

    // ! slower - why is this not optimized away?
    // return pool()[_item].item();
  }

  Item &operator*() const { return item(); }
  Item *operator->() const { return &**this; }

  operator Item &() const { return **this; }
  operator Item *() const { return &**this; }

  template <class _Unused = void> operator Item &&() const {
    return (Item &&)(**this);
  }

private:
  Pool::Handle _item = Pool::Handle::INVALID;
  static constexpr auto &pool() { return Singleton<Pool>::instance(); }

public:
  template <class Parameter>
  using With = owned::Final<decltype(std::tuple_cat(
      std::declval<std::tuple<Parameter>>(), std::declval<Parameters>()))>;

  template <class NewItem> using WithItem = With<parameter::Item<NewItem>>;
  using Weak = With<parameter::WEAK<true>>;

public:
  Weak weak() const { return *this; }

public:
  template <class OtherFinal, class OtherParameters,
            std::enable_if_t<std::is_same_v<Item, typename OtherFinal::Item>>
                * = nullptr>
  bool operator==(const Custom<OtherFinal, OtherParameters> &other) const {
    return this->_item == other._item;
  }

public:
  auto &key() const { return this->_item.value; } // ! remove `.value`

public:
  [[nodiscard]] Owned<const Item> &&freeze() && {
    return reinterpret_cast<Owned<const Item> &&>(*this);
  }

  [[nodiscard]] const Owned<const Item> &&freeze() const && {
    return reinterpret_cast<const Owned<const Item> &&>(*this);
  }

  const Owned<const Item> &frozen() const && {
    static_assert(false, "Owned::frozen() works only for lvalue references");
  }

  [[nodiscard]] Owned<const Item> &frozen() & {
    return reinterpret_cast<Owned<const Item> &>(*this);
  }

  [[nodiscard]] const Owned<const Item> &frozen() const & {
    return reinterpret_cast<const Owned<const Item> &>(*this);
  }

  // public:
  //   auto clone() const {
  //     DCHECK(_item);
  //     using NewSelf = Owned<std::remove_cv_t<Item>>;
  //     if constexpr (has::clone<Item>)
  //       return NewSelf::create(item().clone());
  //     else
  //       return NewSelf::create(item());
  //   }
}; // class Custom

template <class Parameters>
class Final final : public Custom<Final<Parameters>, Parameters> {
  using Base = Custom<Final<Parameters>, Parameters>;
  using Base::Base;

public:
  using Base::operator=;
  Final() = delete;
};

//

// static_assert(sizeof(Owned<int>) == sizeof(int *));

//

#define DEFINE_OPERATOR(op)                                                    \
  template <class Final, class Parameters, class Other>                        \
  auto operator op(const Custom<Final, Parameters> &lhs, Other &&rhs)          \
      ->decltype(*lhs op std::forward<Other>(rhs)) {                           \
    return *lhs op std::forward<Other>(rhs);                                   \
  }                                                                            \
                                                                               \
  template <class Final, class Parameters, class Other>                        \
  auto operator op(Other &&lhs, const Custom<Final, Parameters> &rhs)          \
      ->decltype(std::forward<Other>(lhs) op * rhs) {                          \
    return std::forward<Other>(lhs) op * rhs;                                  \
  }

// ! not sure
// DEFINE_OPERATOR(==)
// DEFINE_OPERATOR(!=)

DEFINE_OPERATOR(<)
DEFINE_OPERATOR(<=)

DEFINE_OPERATOR(>)
DEFINE_OPERATOR(>=)

DEFINE_OPERATOR(+)
DEFINE_OPERATOR(+=)

DEFINE_OPERATOR(-)
DEFINE_OPERATOR(-=)

DEFINE_OPERATOR(*)
DEFINE_OPERATOR(*=)

DEFINE_OPERATOR(/)
DEFINE_OPERATOR(/=)

DEFINE_OPERATOR(%)
DEFINE_OPERATOR(%=)

DEFINE_OPERATOR(<<)
DEFINE_OPERATOR(<<=)

DEFINE_OPERATOR(>>)
DEFINE_OPERATOR(>>=)

DEFINE_OPERATOR(&)
DEFINE_OPERATOR(&=)

DEFINE_OPERATOR(|)
DEFINE_OPERATOR(|=)

DEFINE_OPERATOR(^)
DEFINE_OPERATOR(^=)

DEFINE_OPERATOR(&&)
DEFINE_OPERATOR(||)

#undef DEFINE_OPERATOR

} // namespace VOLTISO_NAMESPACE::owned
