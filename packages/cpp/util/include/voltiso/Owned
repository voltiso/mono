#pragma once
#include <voltiso/_>

#include "voltiso/Object"
#include "voltiso/Pool"
#include "voltiso/getHash"
#include "voltiso/getParameter/Type"
#include "voltiso/getParameter/VALUE"
#include "voltiso/is_trivially_relocatable"
#include "voltiso/parameter"

namespace VOLTISO_NAMESPACE::owned {
template <class Final, class Parameters> class Custom;
template <class Parameters> class Final;
} // namespace VOLTISO_NAMESPACE::owned

namespace VOLTISO_NAMESPACE {
template <class Parameters>
static constexpr auto is_trivially_relocatable<owned::Final<Parameters>> = true;

template <class Item>
using Owned = owned::Final<std::tuple<parameter::Item<Item>>>;

template <class Parameters>
std::size_t getHash(const VOLTISO_NAMESPACE::owned::Final<Parameters> &owned) {
  return getHash(&owned.item());
}
} // namespace VOLTISO_NAMESPACE

namespace VOLTISO_NAMESPACE::owned {
template <class Item> auto create(const Item &item) {
  return Owned<Item>::create(item);
}

template <class Item> auto create(Item &&item) {
  return Owned<std::decay_t<Item>>::create(std::move(item));
}

template <class Final, class Parameters> class Custom : public Object<Final> {
  using Item = getParameter::Type<parameter::Item, Parameters>;
  // static_assert(!std::is_class_v<Item> || std::is_final_v<Item>);
  using Pool = Pool<Item>;
  static constexpr bool WEAK = getParameter::VALUE<parameter::WEAK, Parameters>;

public:
  template <class... Args> static Final create(Args &&...args) {
    Final self;
    self._item = pool().insert(std::forward<Args>(args)...);
    return self;
  }

  static Final create(const Item &item) {
    Final self;
    self._item = pool().insert(item);
    return self;
  }

  // static Final create(Item &&item) {
  //   Final self;
  //   self._item = pool().insert(std::move(item));
  //   return self;
  // }

  ~Custom() {
    static_assert(std::is_final_v<Final>); // need to test somewhere
    if constexpr (!WEAK)
      if (this->_item) [[likely]] {
        // std::cout << "erase" << std::endl;
        pool().erase(this->_item);
        // pool()[this->_item].erase();
      }
  }

  // public: Owned() = default; // convenient, but runtime-bug-prone

protected:
  Custom() = default;

public:
  template <bool W = WEAK, std::enable_if_t<!W> * = nullptr>
  Custom(const Custom &) = delete;

  // template <bool W = WEAK, std::enable_if_t<W> * = nullptr>
  // Custom(const Custom &) = default;

  // copy constructor (for weak)
  template <class OtherFinal, class OtherParameters, bool W = WEAK,
            std::enable_if_t<
                W && std::is_assignable_v<
                         Item *&, typename getParameter::Type<
                                      parameter::Item, OtherParameters> *>> * =
                nullptr>
  Custom(const Custom<OtherFinal, OtherParameters> &other)
      : _item(other._item) {}

  // copy assignment (for weak)
  template <class OtherFinal, class OtherParameters, bool W = WEAK,
            std::enable_if_t<
                W && std::is_assignable_v<
                         Item *&, typename getParameter::Type<
                                      parameter::Item, OtherParameters> *>> * =
                nullptr>
  Custom &operator=(const Custom<OtherFinal, OtherParameters> &other) {
    this->_item = other._item;
    return *this;
  }

  // move assignment (weak -> weak)
  template <class OtherFinal, class OtherParameters,
            std::enable_if_t<
                WEAK && getParameter::VALUE<parameter::WEAK, OtherParameters> &&
                std::is_assignable_v<
                    Item *&, typename getParameter::Type<parameter::Item,
                                                         OtherParameters> *>>
                * = nullptr>
  Custom &operator=(Custom<OtherFinal, OtherParameters> &&other) {
    this->_item = other._item;
    return *this;
  }

  template <class OtherFinal, class OtherParameters> friend class Custom;

  // move constructor (not for weak)
  template <bool W = WEAK, std::enable_if_t<!W> * = nullptr>
  Custom(Custom &&other) noexcept : _item(other._item) {
    other._item = Pool::Handle::null;
    // std::cout << other._item.value << std::endl;
  }

  // move assignment (not for weak)
  template <bool W = WEAK, std::enable_if_t<!W> * = nullptr>
  Custom &operator=(Custom &&other) noexcept {
    if (this->_item) [[likely]]
      pool().erase(this->_item);
    // pool()[this->_item].erase();
    this->_item = other._item;
    other._item = Pool::Handle::null;
    return *this;
  }

  Custom &operator=(const Custom &) = delete;

  // Item &item() { return pool()[_item].item(); }
  // const Item &item() const { return pool()[_item].item(); }

  Item &item() const {
    return *_item;

    // ! slower - why is this not optimized away?
    // return pool()[_item].item();
  }

  Item &operator*() const { return item(); }
  Item *operator->() const { return &**this; }

  operator Item &() const { return **this; }

  template <class _Unused = void> operator Item &&() const {
    return (Item &&)(**this);
  }

private:
  Pool::Handle _item = Pool::Handle::null;
  static constexpr auto &pool() { return Singleton<Pool>::instance(); }

public:
  template <class Parameter>
  using With = owned::Final<decltype(std::tuple_cat(
      std::declval<std::tuple<Parameter>>(), std::declval<Parameters>()))>;

  template <class NewItem> using WithItem = With<parameter::Item<NewItem>>;
  using Weak = With<parameter::WEAK<true>>;

public:
  Weak weak() const { return *this; }

public:
  template <class OtherFinal, class OtherParameters,
            std::enable_if_t<std::is_same_v<Item, typename OtherFinal::Item>>
                * = nullptr>
  bool operator==(const Custom<OtherFinal, OtherParameters> &other) const {
    return this->_item == other._item;
  }

public:
  auto &key() const { return this->_item.value; } // ! remove `.value`

}; // class Custom

template <class Parameters>
class Final final : public Custom<Final<Parameters>, Parameters> {
  using Base = Custom<Final<Parameters>, Parameters>;
  using Base::Base;
};

//

// static_assert(sizeof(Owned<int>) == sizeof(int *));

//

#define DEFINE_OPERATOR(op)                                                    \
  template <class Final, class Parameters, class Other>                        \
  auto operator op(const Custom<Final, Parameters> &lhs, Other &&rhs)          \
      ->decltype(*lhs op std::forward<Other>(rhs)) {                           \
    return *lhs op std::forward<Other>(rhs);                                   \
  }                                                                            \
                                                                               \
  template <class Final, class Parameters, class Other>                        \
  auto operator op(Other &&lhs, const Custom<Final, Parameters> &rhs)          \
      ->decltype(std::forward<Other>(lhs) op * rhs) {                          \
    return std::forward<Other>(lhs) op * rhs;                                  \
  }

// ! not sure
// DEFINE_OPERATOR(==)
// DEFINE_OPERATOR(!=)

DEFINE_OPERATOR(<)
DEFINE_OPERATOR(<=)

DEFINE_OPERATOR(>)
DEFINE_OPERATOR(>=)

DEFINE_OPERATOR(+)
DEFINE_OPERATOR(+=)

DEFINE_OPERATOR(-)
DEFINE_OPERATOR(-=)

DEFINE_OPERATOR(*)
DEFINE_OPERATOR(*=)

DEFINE_OPERATOR(/)
DEFINE_OPERATOR(/=)

DEFINE_OPERATOR(%)
DEFINE_OPERATOR(%=)

DEFINE_OPERATOR(<<)
DEFINE_OPERATOR(<<=)

DEFINE_OPERATOR(>>)
DEFINE_OPERATOR(>>=)

DEFINE_OPERATOR(&)
DEFINE_OPERATOR(&=)

DEFINE_OPERATOR(|)
DEFINE_OPERATOR(|=)

DEFINE_OPERATOR(^)
DEFINE_OPERATOR(^=)

DEFINE_OPERATOR(&&)
DEFINE_OPERATOR(||)

#undef DEFINE_OPERATOR

} // namespace VOLTISO_NAMESPACE::owned
