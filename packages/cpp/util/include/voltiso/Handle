#pragma once
#include <voltiso/_>

#include "voltiso/Object"
#include "voltiso/Options"
#include "voltiso/TypeOption"
#include "voltiso/concepts/Options"
#include "voltiso/option"

#include <cstdint>
#include <limits>
#include <ostream>
#include <type_traits>

//

// forward declarations
namespace VOLTISO_NAMESPACE::handle {
template <class Final, class Options>
  requires concepts::Options<Options>
class Custom;

template <class Options>
  requires concepts::Options<Options>
class Final;
} // namespace VOLTISO_NAMESPACE::handle

//

namespace VOLTISO_NAMESPACE {
using Handle = handle::Final<Options<>>;
// class Handle final : public handle::Custom<Handle, Parameters<>> {
//   using Base = handle::Custom<Handle, Parameters<>>;
//   using Base::Base;
// };
} // namespace VOLTISO_NAMESPACE

//

namespace VOLTISO_NAMESPACE::handle::option {
template <class T> struct Type : TypeOption<T, void *> {};
} // namespace VOLTISO_NAMESPACE::handle::option

//

namespace VOLTISO_NAMESPACE::handle::_ {
template <class Type> constexpr auto getNullValue() noexcept {
  if constexpr (std::is_pointer_v<Type>) {
    return uintptr_t(0);
  } else {
    return std::numeric_limits<Type>::max();
  }
}
} // namespace VOLTISO_NAMESPACE::handle::_

namespace VOLTISO_NAMESPACE::handle {
template <class Final, class Options>
  requires concepts::Options<Options>
class Custom : public Object<Final> {
private:
  using Self = Custom;

public:
  using Brand = Options::template Get<::VOLTISO_NAMESPACE::option::Brand>;
  using Type = Options::template Get<option::Type>;

  using Value =
      std::conditional_t<std::is_pointer_v<Type>, std::uintptr_t, Type>;

  using Pointer = std::conditional_t<std::is_pointer_v<Type>, Type, void>;

  static_assert(std::is_integral_v<Type> || std::is_pointer_v<Type>);
  static_assert(std::is_integral_v<Value>);

public:
  Value value;

  Custom() noexcept = default;

  template <class OtherValue,
            std::enable_if_t<std::is_integral_v<OtherValue> &&
                             sizeof(Value) >= sizeof(OtherValue)> * = nullptr>
  explicit constexpr Custom(const OtherValue &value) noexcept : value(value) {}

  template <class Other,
            std::enable_if_t<(std::is_same_v<Brand, void> ||
                              std::is_same_v<typename Other::Brand, void> ||
                              std::is_same_v<typename Other::Brand, Brand>) &&
                             sizeof(Value) >= sizeof(typename Other::Value)> * =
                nullptr>
  constexpr Custom(const Other &other) : value(other.value) {}

  template <class P = Pointer, class = std::enable_if_t<std::is_pointer_v<P>>>
  constexpr Custom(const std::nullptr_t &) noexcept
      : value(_::getNullValue<Type>()) {}

  explicit constexpr operator Value() const noexcept { return value; }

  bool operator==(const Self &other) const noexcept {
    return value == other.value;
  }

  bool operator!=(const Self &other) const noexcept {
    return value != other.value;
  }

  // can't be defined as constexpr, because can't be defined here inline
  // ...because of CRTP type `Final`
  // static constexpr Final INVALID = static_cast<Final>(
  //     _::getNullValue<typename Custom<Final, Parameters>::Type>());
  static const Final INVALID;

  explicit operator bool() const noexcept { return *this != Self::INVALID; }

  template <class P = Pointer,
            std::enable_if_t<std::is_pointer_v<P>> * = nullptr>
  explicit constexpr Custom(const P &value) noexcept
      : value(reinterpret_cast<Value>(value)) {}

  template <class P = Pointer,
            class = std::enable_if_t<std::is_same_v<P, Pointer> &&
                                     !std::is_same_v<P, void>>>
  operator P() const noexcept {
    return reinterpret_cast<Pointer>(value);
  }

  template <class P = Pointer,
            class = std::enable_if_t<std::is_same_v<P, Pointer> &&
                                     !std::is_same_v<P, void>>>
  operator void *() const noexcept {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
    return std::bit_cast<void *>(value);
#pragma GCC diagnostic pop
  } // operator void *()

  // for pointer-handles
  template <class P = Pointer,
            class = std::enable_if_t<!std::is_same_v<P, void>>>
  auto operator*() const noexcept -> std::remove_pointer_t<P> & {
    return *std::bit_cast<P>(this->value);
  }

  template <class P = Pointer,
            class = std::enable_if_t<!std::is_same_v<P, void>>>
  auto operator->() const noexcept -> P {
    return std::bit_cast<P>(this->value);
  }

public:
  template <class Option>
  using With = handle::Final<typename Options::template With<Option>>;

  template <class NewBrand>
  using WithBrand = With<VOLTISO_NAMESPACE::option::Brand<NewBrand>>;

  template <class NewType> using WithType = With<handle::option::Type<NewType>>;
}; // class Custom

template <class Final, class Options>
  requires concepts::Options<Options>
constexpr Final Custom<Final, Options>::INVALID = static_cast<Final>(
    _::getNullValue<typename Custom<Final, Options>::Type>());

template <class Final, class Options>
  requires concepts::Options<Options>
std::ostream &operator<<(std::ostream &os,
                         const Custom<Final, Options> &handle) {
  if (handle == Custom<Final, Options>::INVALID) [[unlikely]] {
    return os << "Handle::INVALID";
  }
  return os << "Handle(" << handle.value << ")";
} // operator<<

//

template <class Options>
  requires concepts::Options<Options>
class Final final : public Custom<Final<Options>, Options> {
  using Base = Custom<Final<Options>, Options>;

public:
  using Base::Base;
  using Base::operator=;
}; // class Final

} // namespace VOLTISO_NAMESPACE::handle

//

namespace std {
template <class Options>
struct hash<VOLTISO_NAMESPACE::handle::Final<Options>> {
  using Handle = VOLTISO_NAMESPACE::handle::Final<Options>;
  auto operator()(const Handle &handle) const {
    return ::std::hash<typename Handle::Value>{}(handle.value);
  }
};
} // namespace std
