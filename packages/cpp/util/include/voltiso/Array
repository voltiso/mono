#pragma once
#include <voltiso/_>

#include "voltiso/Array.forward.hpp"

#include "voltiso/Handle"
#include "voltiso/Object"
#include "voltiso/RawArray"
#include "voltiso/Slice"
#include "voltiso/ValueOption"
#include "voltiso/concepts/Options"
#include "voltiso/is_trivially_relocatable"
#include "voltiso/memory/Iterator"
#include "voltiso/option"

#include <cstddef>
#include <type_traits>

#include <voltiso/ON>

namespace VOLTISO_NAMESPACE::array::option {
template <std::make_signed_t<std::size_t> N>
struct StartingIndex : ValueOption<N, 0> {};
} // namespace VOLTISO_NAMESPACE::array::option

namespace VOLTISO_NAMESPACE::array {
template <class Final, class Options>
  requires concepts::Options<Options>
class Custom : public Object<Final> {
  using Base = Object<Final>;
  using Self = Custom;

public:
  using Item = Options::template Get<VOLTISO_NAMESPACE::option::Item>;

  static_assert(!std::is_const_v<Item>,
                "const Item does not make sense, just use `const Array<Item>`");

  static constexpr auto NUM_ITEMS =
      Options::template GET<VOLTISO_NAMESPACE::option::NumItems>;

  static constexpr auto STARTING_INDEX =
      Options::template GET<option::StartingIndex>;

  // Make sure required parameters are set
  static_assert(!std::is_same_v<Item, void>, "Item type must be specified");
  static_assert(NUM_ITEMS > 0, "Array size must be greater than 0");

  template <class Type>
  using CustomHandle = Handle::WithBrand<Final>::template WithType<Type>;

  // template <class Type>
  // struct CustomHandle : Handle::WithBrand<Final>::template WithType<Type> {
  //   using Base = Handle::WithBrand<Final>::template WithType<Type>;
  //   using Base::Base;
  //   using Base::operator=;
  // };

  using Handle =
      CustomHandle<std::conditional_t<(STARTING_INDEX < 0),
                                      std::make_signed<size_t>, size_t>>;

  // Item items[NUM_ITEMS];
  RawArray<Item, NUM_ITEMS> items;

public:
  // using Base::Base;
  // using Base::operator=;

public:
  Custom() = default;

  // ! linear-time copy (should be explicit?)
  Custom(const Custom &) = default;
  Custom &operator=(const Custom &) = default;

  // ! allow implicit move (but not copy?)
  Custom(Custom &&) = default;

  // ! implicit linear-time - force consteval?
  Custom(std::initializer_list<Item> list) {
    size_t i = 0;
    for (auto &item : list) {
      items[i++] = item;
    }
    for (; i < NUM_ITEMS; i++) {
      items[i] = Item{};
    }
  }

  static constexpr auto from(const Item (&items)[NUM_ITEMS]) {
    Final result;
    for (size_t i = 0; i < NUM_ITEMS; i++) {
      result.items[i] = items[i];
    }
    return result;
  }

public:
  // ! implicit copy - so force consteval (or use `from` method)
  // for `operator""s`?
  explicit constexpr Custom(const Item (&items)[NUM_ITEMS])
      : Custom(items, std::make_index_sequence<NUM_ITEMS>{}) {}

private:
  template <size_t... INDICES>
  explicit constexpr Custom(const Item (&items)[NUM_ITEMS],
                            std::index_sequence<INDICES...>)
      : items{items[INDICES]...} {}

public:
  template <class InferredHandle,
            std::enable_if_t<std::is_same_v<typename InferredHandle::Brand,
                                            Final>> * = nullptr>
  const Item &operator[](const InferredHandle &handle) const {
    GE(handle.value, STARTING_INDEX);
    LT(handle.value - STARTING_INDEX,
       (std::make_signed_t<decltype(NUM_ITEMS)>)NUM_ITEMS);
    return items[handle.value - STARTING_INDEX];
  }

  template <class InferredHandle,
            std::enable_if_t<std::is_same_v<typename InferredHandle::Brand,
                                            Final>> * = nullptr>
  Item &operator[](const InferredHandle &handle) {
    return const_cast<Item &>(const_cast<const Custom &>(*this)[handle]);
  }

  // Automatic deduction does not work when assigning raw value, since the above
  // methods are templated, and creating handle from a raw value is ambiguous
  // (we can create a larger handle from a smaller value), se below we
  // explicitly define `operator[]` for raw values

  template <class Index, class = std::enable_if_t<std::is_integral_v<Index>>>
  const Item &operator[](const Index &index) const {
    return (*this)[CustomHandle<Index>(index)];
  }

  template <class Index, class = std::enable_if_t<std::is_integral_v<Index>>>
  Item &operator[](const Index &index) {
    return (*this)[CustomHandle<Index>(index)];
  }

  // comparisons
  constexpr bool operator==(const Custom &other) const {
    return NUM_ITEMS == other.NUM_ITEMS &&
           std::equal(items, items + NUM_ITEMS, other.items);
  }

  // raw array conversion should be explicit (can loose size information)
  explicit operator RawArray<Item, NUM_ITEMS> &() { return items; }

  // raw array conversion should be explicit (can loose size information)
  explicit operator const RawArray<Item, NUM_ITEMS> &() const { return items; }

  // string_view is constant-time, so can be implicit
  constexpr operator ::std::string_view() const
    requires std::is_same_v<Item, char>
  {
    // omit null terminator
    return ::std::string_view(items, NUM_ITEMS - 1);
  }

  // constant-time - can be implicit
  constexpr operator Slice<Item[NUM_ITEMS]>() {
    return Slice<Item[NUM_ITEMS]>(items);
  }
  constexpr operator Slice<const Item[NUM_ITEMS]>() const {
    return Slice<const Item[NUM_ITEMS]>(items);
  }

  /**
   *  - Invalidates on relocation
   */
  class Iterator final : public memory::IteratorCrtp<Item, Iterator> {
  public:
    using Self = Iterator;
    using Base = memory::IteratorCrtp<Item, Iterator>;
    using Item = Item;
    using Base::Base;
  };

  /**
   *  - Invalidates on relocation
   */
  class ConstIterator final
      : public memory::ConstIteratorCrtp<Item, ConstIterator> {
  public:
    using Self = ConstIterator;
    using Base = memory::ConstIteratorCrtp<Item, ConstIterator>;
    using Item = Item;
    using Base::Base;
  };

  Iterator begin() { return Iterator{items}; }
  Iterator end() { return Iterator{items + NUM_ITEMS}; }

  ConstIterator begin() const { return ConstIterator{items}; }
  ConstIterator end() const { return ConstIterator{items + NUM_ITEMS}; }

  // for std
  constexpr size_t size() const noexcept { return NUM_ITEMS; }

public:
  template <class Parameter>
  using With =
      Custom<Final,
             decltype(std::tuple_cat(std::declval<std::tuple<Parameter>>(),
                                     std::declval<Options>()))>;

  template <class T> using WithItem = With<VOLTISO_NAMESPACE::option::Item<T>>;

  template <size_t N>
  using WithSize = With<VOLTISO_NAMESPACE::option::NumItems<N>>;

  template <size_t N> using WithStartingIndex = With<option::StartingIndex<N>>;
}; // class Custom
} // namespace VOLTISO_NAMESPACE::array

namespace std {
template <class Final, class... Options>
ostream &
operator<<(ostream &os,
           const VOLTISO_NAMESPACE::array::Custom<Final, Options...> &array) {
  using Array = VOLTISO_NAMESPACE::array::Custom<Final, Options...>;
  os << "[";
  for (size_t i = 0; i < Array::NUM_ITEMS; i++) {
    if (i > 0) {
      os << ", ";
    }
    os << array[i];
  }
  return os << "]";
}
} // namespace std

namespace VOLTISO_NAMESPACE {
template <class Final, class... Options>
static constexpr auto
    is_trivially_relocatable<array::Custom<Final, Options...>> = true;

template <class Item, size_t NUM_ITEMS>
class Array final
    : public array::Custom<
          Array<Item, NUM_ITEMS>,
          Options<option::Item<Item>, option::NumItems<NUM_ITEMS>>> {
  using Base =
      array::Custom<Array<Item, NUM_ITEMS>,
                    Options<option::Item<Item>, option::NumItems<NUM_ITEMS>>>;

public:
  using Base::Base; // Inherit constructors
};

// Deduction guide (similar to std::array)
template <class T, class... U,
          std::enable_if_t<std::conjunction_v<std::is_same<T, U>...>, int> = 0>
Array(T, U...) -> Array<std::type_identity_t<T>, 1 + sizeof...(U)>;

// ! implicit linear-time copy
// Deduction guide for constructing from a raw array
template <class Item, size_t NUM_ITEMS>
Array(const Item (&)[NUM_ITEMS]) -> Array<Item, NUM_ITEMS>;

namespace array {
template <class Item, size_t NUM_ITEMS>
inline constexpr auto from(const Item (&rawArray)[NUM_ITEMS]) {
  return Array<Item, NUM_ITEMS>::from(rawArray);
}
} // namespace array

} // namespace VOLTISO_NAMESPACE

namespace std {
template <class T>
  requires requires(T t) { T::NUM_ITEMS; }
struct tuple_size<T> : std::integral_constant<std::size_t, T::NUM_ITEMS> {};
template <class T>
  requires requires(T t) { T::EXTENT; }
struct tuple_size<T> : std::integral_constant<std::size_t, T::EXTENT> {};
} // namespace std

#include <voltiso/OFF>
