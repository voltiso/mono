#pragma once
#include <voltiso/_>

#include "voltiso/Slice"
#include "voltiso/assert"

namespace VOLTISO_NAMESPACE {
template <size_t NUM_CHARS>
class ConstStringSlice : public Slice<const char[NUM_CHARS]> {

public:
  constexpr ConstStringSlice(const char (&chars)[NUM_CHARS + 1])
      : Slice<const char[NUM_CHARS]>(
            reinterpret_cast<const char (&)[NUM_CHARS]>(chars)) {
    // static_assert(chars[NUM_CHARS] == '\0',
    //               "StringSlice must be null-terminated");

    VOLTISO_EQ(chars[NUM_CHARS], '\0');
  }

  constexpr bool operator==(const ConstStringSlice &other) const {
    // todo: we could have traits `is_trivially_equal_comparable` and
    // `is_trivially_less_comparable` - and use memcmp
    // (or `binary` instead of `trivially`)
    // return items == other.items ||
    //        memcmp(items, other.items, sizeof(RawArray)) == 0;
    if (&this->items == &other.items) [[unlikely]] {
      return true; // assume a==a
    }

    for (size_t i = 0; i < NUM_CHARS; i++) {
      if (this->items[i] != other.items[i]) {
        return false;
      }
    }
    return true;
  }

  // for std?
  constexpr size_t size() const noexcept { return NUM_CHARS; }
}; // class StringSlice

// deduction guide for raw arrays
template <size_t N>
ConstStringSlice(const char (&)[N]) -> ConstStringSlice<N - 1>;

// deduction guide for custom tuples
template <class TArray>
  requires(!std::is_array_v<TArray> &&
           std::is_same_v<
               std::remove_reference_t<decltype(std::declval<TArray>()[0])>,
               const char>)
ConstStringSlice(TArray &array)
    -> ConstStringSlice<std::tuple_size<TArray>::value>;

} // namespace VOLTISO_NAMESPACE
