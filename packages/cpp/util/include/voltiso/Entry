#pragma once
#include <voltiso/_>

#include "voltiso/has"
#include "voltiso/is_trivially_relocatable"

#include <type_traits>

namespace VOLTISO_NAMESPACE {
template <class _Key, class _Value> struct Entry {
  using Key = _Key;
  using Value = _Value;
  Key key;
  Value value;
};

template <class Key, class Value>
static constexpr auto is_trivially_relocatable<Entry<Key, Value>> =
    is_trivially_relocatable<Key> && is_trivially_relocatable<Value>;

//

template <class Item, class = std::enable_if_t<has::entry<Item>>>
constexpr auto &getEntry(Item &item) {
  if constexpr (has::function::entry<Item>) {
    return item.entry();
  } else {
    return item.entry;
  }
}

template <class Item, class = std::enable_if_t<has::entry<Item>>>
constexpr const auto &getEntry(const Item &item) {
  return getEntry(const_cast<Item &>(item));
}

// getKey

template <class Item, std::enable_if_t<has::key<Item>> * = nullptr>
constexpr auto &getKey(Item &item) {
  if constexpr (has::function::key<Item>) {
    return item.key();
  } else {
    return item.key;
  }
}

template <class Item,
          std::enable_if_t<!has::key<Item> && !has::entry<Item>> * = nullptr>
constexpr auto &getKey(Item &item) {
  return item; // identity function by default
}

template <class Item, std::enable_if_t<has::entry<Item>> * = nullptr>
constexpr auto &getKey(Item &item) {
  return getKey(getEntry(item));
}

template <class Item> constexpr const auto &getKey(const Item &item) {
  return getKey(const_cast<Item &>(item));
}

namespace _ {
template <class Item> struct GetKeyImpl {
  using Type = std::decay_t<decltype(getKey(std::declval<Item>()))>;
};
template <class Key, class Value> struct GetKeyImpl<Entry<Key, Value>> {
  using Type = Key;
};
} // namespace _

template <class Item> using GetKey = _::GetKeyImpl<Item>::Type;

// getValue

template <class Item, class = std::enable_if_t<has::value<Item>>>
constexpr auto &getValue(Item &item) {
  if constexpr (has::function::value<Item>) {
    return item.value();
  } else {
    return item.value;
  }
}

template <class Item,
          std::enable_if_t<!has::value<Item> && !has::entry<Item>> * = nullptr>
constexpr auto &getValue(Item &item) {
  return item; // identity function by default
}

template <class Item, std::enable_if_t<has::entry<Item>> * = nullptr>
constexpr auto &getValue(Item &item) {
  return getValue(getEntry(item));
}

template <class Item> constexpr const auto &getValue(const Item &item) {
  return getValue(const_cast<Item &>(item));
}

// // disable this?
// template <
//     class Item, std::enable_if_t<!std::is_integral_v<Item>> * = nullptr,
//     class = decltype(std::declval<std::hash<Item>>()(std::declval<Item>()))>
// constexpr auto getKey(const Item &item) {
//   return std::hash<Item>{}(item);
// }

// template <class Item, std::enable_if_t<std::is_integral_v<Item>> * = nullptr>
// constexpr auto getKey(const Item &item) {
//   return item;
// }

// // disable this?
// template <class Item, decltype(std::declval<std::hash<Item>>()(
//                           std::declval<Item>())) * = nullptr>
// constexpr auto &getValue(Item &item) {
//   return item;
// }

// template <class Item, decltype(std::declval<std::hash<Item>>()(
//                           std::declval<Item>())) * = nullptr>
// constexpr const auto &getValue(const Item &item) {
//   return getValue(const_cast<Item &>(item));
// }

//

//

// template <class = void> constexpr void getValue(...) {
//   static_assert(false, "entry type does not have a value (key-only entry or "
//                        "`getValue` is not defined for your custom type)");
// }

// template <class Item> using GetValue =
// decltype(getValue(std::declval<Item>()));

//

namespace _ {
template <class Item> struct GetValueImpl {
  using Type = std::decay_t<decltype(getValue(std::declval<Item>()))>;
};
template <class Key, class Value> struct GetValueImpl<Entry<Key, Value>> {
  using Type = Value;
};
} // namespace _

template <class Item> using GetValue = _::GetValueImpl<Item>::Type;

//

template <class Item>
using GetEntry = std::decay_t<decltype(getEntry(std::declval<Item>()))>;

} // namespace VOLTISO_NAMESPACE
