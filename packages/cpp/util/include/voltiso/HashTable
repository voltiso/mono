#pragma once
#include <voltiso/_>

#include "voltiso/DynamicArray.hpp"
#include "voltiso/Entry"
#include "voltiso/Object"
#include "voltiso/Pool"
#include "voltiso/getHash"
#include "voltiso/is_trivially_relocatable"

#include <type_traits>

// ! todo: can be made faster by using a single growable allocation for both
// ! pool and buckets

namespace VOLTISO_NAMESPACE {
namespace hashTable {
template <class Final, class Parameters> class Custom;
template <class Parameters> class Final;
} // namespace hashTable

namespace hashTable::_ {
template <class Final, class Parameters> class Iterator;
} // namespace hashTable::_

template <class Entry>
using HashTable = hashTable::Final<std::tuple<parameter::Entry<Entry>>>;

template <class Parameters>
static constexpr auto is_trivially_relocatable<hashTable::Final<Parameters>> =
    true;
} // namespace VOLTISO_NAMESPACE

//

namespace VOLTISO_NAMESPACE::hashTable::_ {

template <class Final, class Parameters>
using GenericPool = Pool<int>::template WithAllocator<
    getParameter::Type<parameter::Allocator, Parameters>>;

template <class Final, class Parameters>
using GenericPoolHandle =
    typename GenericPool<Final, Parameters>::Handle::template WithBrand<void>;

template <class Final, class Parameters> struct Node {
  using GenericPoolHandle = GenericPoolHandle<Final, Parameters>;
  using Custom = Custom<Final, Parameters>;
  using Entry = Custom::Entry;
  Entry entry;
  GenericPoolHandle nextNode = GenericPoolHandle::INVALID;
}; // struct Node

template <class Final, class Parameters>
using Pool = Pool<Node<Final, Parameters>>::template WithAllocator<
    getParameter::Type<parameter::Allocator, Parameters>>;

template <class Final, class Parameters> struct Bucket {
  using Node = Node<Final, Parameters>;
  using GenericPoolHandle = GenericPoolHandle<Final, Parameters>;
  GenericPoolHandle firstNode = GenericPoolHandle::INVALID;
}; // struct Bucket

template <class Final, class Parameters>
using Buckets = DynamicArray<Bucket<Final, Parameters>>::template WithAllocator<
    getParameter::Type<parameter::Allocator, Parameters>>;

} // namespace VOLTISO_NAMESPACE::hashTable::_

//

namespace VOLTISO_NAMESPACE {
template <class Final, class Parameters>
static constexpr auto
    is_trivially_relocatable<hashTable::_::Bucket<Final, Parameters>> = true;
} // namespace VOLTISO_NAMESPACE

//

namespace VOLTISO_NAMESPACE::hashTable::_ {
template <class Final, class Parameters, bool IS_CONST> class Accessor {
private:
  using GenericPoolHandle = GenericPoolHandle<Final, Parameters>;
  using Custom = Custom<Final, Parameters>;
  using Value = typename Custom::Value;
  using Buckets = typename Custom::Buckets;

protected:
  GenericPoolHandle const *const pHandle;
  // const GenericPoolHandle handle;
  const Buckets::Handle bucket;

public:
  // const Key key;
  const bool exists;
  const Custom &hashTable;

protected:
  friend Custom;
  Accessor(const Custom &hashTable, const GenericPoolHandle *pHandle,
           const Buckets::Handle &bucket, bool exists)
      : pHandle(pHandle), bucket(bucket), exists(exists), hashTable(hashTable) {
  }
  // const auto &hashTable() const { return _hashTable; }

public:
  const Value &value() const {
    DCHECK(this->exists);
    return getValue(this->hashTable.pool[*this->pHandle]->entry);
  }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  Value &value() {
    DCHECK(this->exists);
    return getValue(this->_pool()[*this->pHandle]->entry);
  }

public:
  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  void erase() {
    DCHECK(this->exists);
    auto &pool = this->_pool();
    auto node = pool[*this->pHandle];
    this->_handle() = node->nextNode;
    node.erase();
    --this->_hashTable()._numItems();
  }

public:
  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  void maybeErase() {
    if (this->exists) {
      erase();
    }
  }

public:
  explicit operator bool() const { return exists; }

  operator const Value &() const { return value(); }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  operator Value &() {
    return value();
  }

  const Value &operator*() const { return value(); }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  Value &operator*() {
    return value();
  }

  const std::remove_reference_t<Value> *operator->() const { return &value(); }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  std::remove_reference_t<Value> *operator->() {
    return &value();
  }

  const std::remove_reference_t<Value> *operator&() const { return &value(); }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  std::remove_reference_t<Value> *operator&() {
    return &value();
  }

protected:
  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  auto &_hashTable() {
    return const_cast<Custom &>(this->hashTable);
  }

  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  auto &_handle() {
    return const_cast<GenericPoolHandle &>(*this->pHandle);
  }

  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  auto &_pool() {
    return this->_hashTable()._pool();
  }

  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  auto &_buckets() {
    return this->_hashTable()._buckets();
  }

}; // class ConstAccessor

template <class Final, class Parameters, bool IS_CONST>
class SetAccessor : public Accessor<Final, Parameters, IS_CONST> {
private:
  using Base = Accessor<Final, Parameters, IS_CONST>;
  using Base::Base;
  using Self = SetAccessor;

private:
  using GenericPoolHandle = GenericPoolHandle<Final, Parameters>;
  using Custom = Custom<Final, Parameters>;
  using Value = typename Custom::Value;
  using Bucket = Bucket<Final, Parameters>;
  using Buckets = Buckets<Final, Parameters>;
  using Entry = typename Custom::Entry;
  using Key = typename Custom::Key;

public:
  const Entry &entry; // can be move-only

protected:
  friend Custom;
  SetAccessor(const Custom &hashTable, const GenericPoolHandle *pHandle,
              const Buckets::Handle &bucket, bool exists, const Entry &entry)
      : Base(hashTable, pHandle, bucket, exists), entry(entry) {}

protected:
  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  void _maybeGrow() {
    if (this->_hashTable().shouldGrow()) [[unlikely]] {
      this->_hashTable().grow();
      const_cast<Buckets::Handle &>(this->bucket) =
          this->_hashTable()._bucketIndex(getKey(this->entry));
    }
  }

public:
  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  Self &insert() {
    DCHECK(!this->exists);
    this->_maybeGrow();
    auto &pool = this->_pool();
    auto node = pool.insert(this->entry).handle;
    auto &buckets = this->_buckets();
    auto &bucket = buckets[this->bucket].item();
    pool[node]->nextNode = bucket.firstNode;
    bucket.firstNode = node;
    const_cast<GenericPoolHandle *&>(this->pHandle) = &bucket.firstNode;
    ++this->_hashTable()._numItems();
    return *this;
  }

  Self &maybeInsert() {
    if (!this->exists) {
      insert();
    }
    return *this;
  }

  Self &maybeInsertLikely() {
    if (!this->exists) [[likely]] {
      insert();
    }
    return *this;
  }

  Self &maybeInsertUnlikely() {
    if (!this->exists) [[unlikely]] {
      insert();
    }
    return *this;
  }

  void set() {
    if (!this->exists) {
      insert();
    }
  }

  // explicit operator bool() const { return this->exists; }

public:
  Value &value() { return const_cast<Value &>(Base::value()); }
  operator Value &() { return value(); }
  Value &operator*() { return value(); }
  std::remove_reference_t<Value> *operator->() { return &value(); }
  std::remove_reference_t<Value> *operator&() { return &value(); }
}; // class SetAccessor

template <class Final, class Parameters, bool IS_CONST>
class MapAccessor : public Accessor<Final, Parameters, IS_CONST> {
private:
  using Self = MapAccessor;
  using Base = Accessor<Final, Parameters, IS_CONST>;
  using Base::Base;
  using Custom = Custom<Final, Parameters>;
  using Buckets = typename Custom::Buckets;
  using Value = typename Custom::Value;
  using GenericPoolHandle = GenericPoolHandle<Final, Parameters>;
  using Entry = typename Custom::Entry;
  using Key = typename Custom::Key;

public:
  const Key &key;

protected:
  friend Custom;

  MapAccessor(const Custom &hashTable, const GenericPoolHandle *pHandle,
              const Buckets::Handle &bucket, bool exists, const Key &key)
      : Base(hashTable, pHandle, bucket, exists), key(key) {}

  template <class K>
  MapAccessor(const Custom &hashTable, const GenericPoolHandle *pHandle,
              const Buckets::Handle &bucket, bool exists, const K &key)
      : Base(hashTable, pHandle, bucket, exists), key(getKey(key)) {}

protected:
  template <bool C = IS_CONST, std::enable_if_t<C == false> * = nullptr>
  void _maybeGrow() {
    if (this->_hashTable().shouldGrow()) [[unlikely]] {
      this->_hashTable().grow();
      const_cast<Buckets::Handle &>(this->bucket) =
          this->_hashTable()._bucketIndex(this->key);
    }
  }

public:
  template <class... Args, bool C = IS_CONST,
            std::enable_if_t<C == false> * = nullptr>
  void insert(Args &&...args) {
    DCHECK(!this->exists);
    this->_maybeGrow();
    auto &pool = this->_pool();
    auto node =
        pool.insert(Entry{this->key, Value{std::forward<Args>(args)...}});
    auto &buckets = this->_buckets();
    auto &bucket = buckets[this->bucket].item();
    node->nextNode = bucket.firstNode;
    bucket.firstNode = node.handle;
    const_cast<GenericPoolHandle *&>(this->pHandle) = &bucket.firstNode;
    ++this->_hashTable()._numItems();
    const_cast<bool &>(this->exists) = true;
  }

  template <class V = Value,
            std::enable_if_t<std::is_reference_v<V>> * = nullptr>
  void insert(Value value) {
    DCHECK(!this->exists);
    this->_maybeGrow();
    auto &pool = this->_pool();
    auto node = pool.insert(Entry{this->key, value});
    auto &buckets = this->_buckets();
    auto &bucket = buckets[this->bucket].item();
    node->nextNode = bucket.firstNode;
    bucket.firstNode = node.handle;
    const_cast<GenericPoolHandle *&>(this->pHandle) = &bucket.firstNode;
    ++this->_hashTable()._numItems();
    const_cast<bool &>(this->exists) = true;
  }

  //

  template <class... Args> Self &maybeInsert(Args &&...args) {
    if (!this->exists) {
      insert(std::forward<Args>(args)...);
    }
    return *this;
  }

  auto &maybeInsert(const Value &value) { return this->maybeInsert<>(value); }

  template <class V = Value,
            std::enable_if_t<!std::is_reference_v<V>> * = nullptr>
  auto &maybeInsert(Value &&value) {
    return this->maybeInsert<>(std::move(value));
  }

  template <class... Args> Self &maybeInsertLikely(Args &&...args) {
    if (!this->exists) [[likely]] {
      insert(std::forward<Args>(args)...);
    }
    return *this;
  }

  auto &maybeInsertLikely(const Value &value) {
    return this->maybeInsertLikely<>(value);
  }

  template <class V = Value,
            std::enable_if_t<!std::is_reference_v<V>> * = nullptr>
  auto &maybeInsertLikely(Value &&value) {
    return this->maybeInsertLikely<>(std::move(value));
  }

  template <class... Args> Self &maybeInsertUnlikely(Args &&...args) {
    if (!this->exists) [[unlikely]] {
      insert(std::forward<Args>(args)...);
    }
    return *this;
  }

  auto &maybeInsertUnlikely(const Value &value) {
    return this->maybeInsertUnlikely<>(value);
  }

  template <class V = Value,
            std::enable_if_t<!std::is_reference_v<V>> * = nullptr>
  auto &maybeInsertUnlikely(Value &&value) {
    return this->maybeInsertUnlikely<>(std::move(value));
  }

  //

  template <class... Args> void update(Args &&...args) {
    DCHECK(this->exists);
    auto &bucket =
        const_cast<Buckets &>(this->hashTable().buckets)[this->handle.bucket];
    auto &value = getValue(bucket.entries[this->handle.entry]);
    value = Value(std::forward<Args>(args)...);
    // value.~Value();
    // new (&value) Value(std::forward<Args>(args)...);
  }

  template <class... Args> void set(Args &&...args) {
    if (this->exists) {
      update(std::forward<Args>(args)...);
    } else {
      insert(std::forward<Args>(args)...);
    }
  }

  template <class Value> auto &operator=(Value &&value) {
    set(std::forward<Value>(value));
    return *this;
  }

  auto &operator=(const Value &value) {
    set(value);
    return *this;
  }

  template <class V = Value,
            std::enable_if_t<!std::is_reference_v<V>> * = nullptr>
  auto &operator=(Value &&value) {
    set(std::move(value));
    return *this;
  }
}; // class MapAccessor

template <class Final, class Parameters> class ConstIterator {
private:
  using Custom = Custom<Final, Parameters>;
  using Buckets = typename Custom::Buckets;
  using Pool = Pool<Final, Parameters>;
  using Entry = typename Custom::Entry;

private:
  Buckets::Handle bucket;
  Pool::Handle node;
  const Custom &hashTable;

private:
  friend Custom;
  friend Iterator<Final, Parameters>;
  ConstIterator(const Buckets::Handle &bucket, const Pool::Handle &node,
                const Custom &hashTable)
      : bucket(bucket), node(node), hashTable(hashTable) {}

public:
  /** @internal - works only for comparisons with .end() */
  bool operator!=(const ConstIterator &other) const {
    DCHECK_EQ(&hashTable, &other.hashTable);
    return !!this->node; // !
  }

  auto &operator++() {
    if (this->node) {
      auto &pool = this->hashTable.pool;
      this->node = pool[this->node]->nextNode;
    } else {
      ++this->bucket.value;
      auto &buckets = this->hashTable.buckets;
      this->node = buckets[bucket]->firstNode;
    }
    return *this;
  }

  const Entry &operator*() const {
    auto &pool = this->hashTable.pool;
    return pool[node]->entry;
  }
}; // class ConstIterator

template <class Final, class Parameters>
class Iterator : public ConstIterator<Final, Parameters> {
private:
  using Base = ConstIterator<Final, Parameters>;
  using Custom = Custom<Final, Parameters>;
  using Buckets = Buckets<Final, Parameters>;
  using Pool = Pool<Final, Parameters>;
  using Entry = typename Custom::Entry;

private:
  friend Custom;
  Iterator(const Buckets::Handle &bucket, const Pool::Handle &node,
           Custom &hashTable)
      : Base(bucket, node, hashTable) {}

private:
  auto &_hashTable() { return const_cast<Custom &>(this->hashTable); }

public:
  Entry &operator*() { return this->_hashTable()._pool()[this->node]->entry; }
}; // class Iterator
} // namespace VOLTISO_NAMESPACE::hashTable::_

//

namespace VOLTISO_NAMESPACE::hashTable {
// struct Defaults {
//   using Entry = void; // need to override
//   using Allocator = allocator::Malloc;
// };

//

template <class Final, class Parameters> class Custom : public Object<Final> {
private:
  using Self = Custom;

public:
  using Entry = getParameter::Type<parameter::Entry, Parameters>;
  using Key = GetKey<Entry>;
  using Value = GetValue<Entry>;

  // static_assert(std::is_trivially_copyable_v<Key>);

  static_assert(!std::is_same_v<Key, void>);
  static_assert(!std::is_same_v<Value, void>);

private:
  using Allocator = getParameter::Type<parameter::Allocator, Parameters>;
  using Bucket = _::Bucket<Final, Parameters>;
  using Buckets = _::Buckets<Final, Parameters>;
  using Node = _::Node<Final, Parameters>;
  using Pool = _::Pool<Final, Parameters>;
  using GenericPoolHandle = _::GenericPoolHandle<Final, Parameters>;

public:
  Buckets const buckets = {};
  Pool const pool = {}; // for better data locality, we keep internal pool
  size_t const numItems = 0;

  bool hasItems() const { return numItems; }

private:
  Buckets &_buckets() { return const_cast<Buckets &>(this->buckets); }
  Pool &_pool() { return const_cast<Pool &>(this->pool); }
  size_t &_numItems() { return const_cast<size_t &>(this->numItems); }

public:
  ~Custom() {
    for (size_t i = 0; i < buckets.numItems; ++i) {
      auto node = std::bit_cast<typename Pool::Handle>(buckets[i]->firstNode);
      while (node) {
        auto nextNode = node->nextNode;
        _pool().erase(node);
        node = nextNode;
      }
    }
  }

  // private:
  //   void _debug_print() {
  //     LOG(INFO) << "HashTable";
  //     LOG(INFO) << "numBuckets " << this->buckets.numItems;
  //     for (auto &bucket : this->buckets) {
  //       LOG(INFO) << "bucket has items " << !!bucket.firstNode;
  //     }
  //   }

public:
  Custom() = default;
  Custom(std::initializer_list<Entry> entries) {
    auto numBuckets = std::bit_ceil(entries.size()) * MAX_LOAD_FACTOR_INV;
    auto &buckets = this->_buckets();
    buckets.setNumItems(numBuckets);
    for (auto &entry : entries) {
      // LOG(INFO) << "insert " << entry;
      this->insert(entry);
      // _debug_print();
    }
  }

  //

  friend _::Accessor<Final, Parameters, true>;
  friend _::Accessor<Final, Parameters, false>;

  using SetAccessor = _::SetAccessor<Final, Parameters, false>;
  friend SetAccessor;

  using ConstSetAccessor = _::SetAccessor<Final, Parameters, true>;
  friend ConstSetAccessor;

  using MapAccessor = _::MapAccessor<Final, Parameters, false>;
  friend MapAccessor;

  using ConstMapAccessor = _::MapAccessor<Final, Parameters, true>;
  friend MapAccessor;

  //

  using Iterator = _::Iterator<Final, Parameters>;
  friend Iterator;

  using ConstIterator = _::ConstIterator<Final, Parameters>;
  friend ConstIterator;

private:
  Buckets::Handle _bucketIndex(const Key &key) const {
    // LOG(INFO) << "get bucket index for key " << key;
    auto hash = getHash<Key>(key);
    // LOG(INFO) << "hash is " << hash;
    DCHECK(std::has_single_bit(buckets.numItems));
    // auto index = hash % buckets.numItems;
    auto index = hash & (buckets.numItems - 1);
    return typename Buckets::Handle(index);
  }

  template <class K> auto _bucketIndex(const K &key) const {
    return this->_bucketIndex(getKey(key));
  }

private:
  void grow() {
    auto newNumBuckets = buckets.numItems << 1;
    if (!newNumBuckets) [[unlikely]]
      newNumBuckets = 1;
    setNumBuckets(newNumBuckets);
  }

  void setNumBuckets(std::size_t newNumBuckets) {
    DCHECK(std::has_single_bit(newNumBuckets));
    auto &buckets = this->_buckets();
    auto &pool = this->_pool();
    auto oldNumBuckets = buckets.numItems;
    buckets.setNumItems(newNumBuckets);
    for (size_t i = 0; i < oldNumBuckets; ++i) {
      auto &oldBucket = buckets[i].item();
      auto pNode = &oldBucket.firstNode;
      while (*pNode) {
        auto newIndex = _bucketIndex(getKey(pool[*pNode]->entry));
        if (newIndex.value == i) {
          pNode = &pool[*pNode]->nextNode;
        } else if (newIndex.value != i) {
          auto oldBucketRest = pool[*pNode]->nextNode;
          auto &newBucket = buckets[newIndex].item();
          auto newBucketRest = newBucket.firstNode;
          newBucket.firstNode = *pNode;
          pool[*pNode]->nextNode = newBucketRest;
          *pNode = oldBucketRest;
        }
      }
    }
  }

  static constexpr size_t MAX_LOAD_FACTOR_INV = 2; // 0.5 load factor

  bool shouldGrow() const {
    return MAX_LOAD_FACTOR_INV * numItems >= buckets.numItems;
  }

  void maybeGrow() {
    if (this->shouldGrow()) [[unlikely]]
      this->grow();
  }

public:
  bool has(const Key &key) const { return this->operator[](key).exists; }

  template <class K,
            std::enable_if_t<std::is_convertible_v<GetKey<K>, Key>> * = nullptr>
  bool has(const K &key) const {
    return has(getKey(key));
  }

public:
  template <class... Args> Handle insert(Args &&...args) {
    this->maybeGrow();
    auto node = this->_pool().insert(std::forward<Args>(args)...);
    // auto &buckets = this->_buckets();
    // LOG(INFO) << "Key = " << demangle(typeid(Key));
    // LOG(INFO) << "Argument = " << demangle(typeid(node));
    auto bucketIndex = this->_bucketIndex(getKey(node->entry));
    // LOG(INFO) << "insert at bucket index " << bucketIndex;
    auto &bucket = buckets[bucketIndex].item();
    node->nextNode = bucket.firstNode;
    const_cast<GenericPoolHandle &>(bucket.firstNode) = node.handle;
    ++this->_numItems();
    return node.handle;
    // return {&bucket.firstNode, bucketIndex, getKey(node->entry), true,
    // *this};
  }

public:
  template <class TEntry>
    requires std::is_same_v<Entry, std::decay_t<TEntry>>
  auto maybeInsert(TEntry &&entry) {
    // todo: should be other way around I guess?
    return this->operator[](std::forward<TEntry>(entry)).maybeInsert();
  }

public:
  void erase(const Entry &entry) { this->operator[](entry).erase(); }

  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  void erase(const Key &key) {
    this->operator[](key).erase();
  }

  void maybeErase(const Entry &entry) { this->operator[](entry).maybeErase(); }

  // template <class E,
  //           std::enable_if_t<std::is_convertible_v<E, Entry>> * = nullptr>
  // void maybeErase(const E &entry) {
  //   this->operator[](entry).erase();
  // }

  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  void maybeErase(const Key &key) {
    this->operator[](key).maybeErase();
  }

  template <class K,
            std::enable_if_t<std::is_convertible_v<K, Key>> * = nullptr>
  void maybeErase(const K &key) {
    return this->operator[](key).maybeErase();
  }

  template <class K,
            std::enable_if_t<std::is_convertible_v<GetKey<K>, Key>> * = nullptr>
  void maybeErase(const K &key) {
    return this->operator[](getKey(key)).maybeErase();
  }

public:
  // template <class E, std::enable_if_t<std::is_same_v<
  //                        std::remove_cv_t<std::remove_reference_t<E>>,
  //                        Entry>>
  //                        * = nullptr>
  SetAccessor operator[](const Entry &entry) {
    auto &key = getKey(entry);
    if (buckets.numItems == 0) [[unlikely]]
      return {*this, nullptr, typename Buckets::Handle(0), false, entry};
    auto bucket = _bucketIndex(key);
    auto pHandle = &buckets[bucket]->firstNode;
    if constexpr (std::is_reference_v<Key>) {
      while (*pHandle && (&getKey(pool[*pHandle]->entry) != &key)) {
        pHandle = &pool[*pHandle]->nextNode;
      }
    } else {
      while (*pHandle && getKey(pool[*pHandle]->entry) != key) {
        pHandle = &pool[*pHandle]->nextNode;
      }
    }
    bool exists = (bool)(*pHandle);
    return {*this, pHandle, bucket, exists, entry};
  }

  template <class E,
            std::enable_if_t<std::is_convertible_v<E, Entry>> * = nullptr>
  auto operator[](const E &entry) {
    return this->operator[](static_cast<Entry>(entry));
  }

  // template <class E, std::enable_if_t<std::is_same_v<
  //                        std::remove_cv_t<std::remove_reference_t<E>>,
  //                        Entry>>
  //                        * = nullptr>
  ConstSetAccessor operator[](const Entry &entry) const {
    auto accessor = const_cast<Self &>(*this)[entry];
    return std::bit_cast<ConstSetAccessor>(accessor); // rvo works?
  }

  template <class E,
            std::enable_if_t<std::is_convertible_v<E, Entry>> * = nullptr>
  auto operator[](const E &entry) const {
    return this->operator[](static_cast<Entry>(entry));
  }

  // template <class K,
  //           std::enable_if_t<std::is_same_v<
  //               std::remove_cv_t<std::remove_reference_t<K>>, Key>> * =
  //               nullptr>
  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  MapAccessor operator[](const Key &key) {
    if (buckets.numItems == 0) [[unlikely]]
      return {*this, nullptr, typename Buckets::Handle(0), false, key};
    auto bucket = _bucketIndex(key);
    auto pHandle = &buckets[bucket]->firstNode;
    while (*pHandle && getKey(pool[*pHandle]->entry) != key) {
      pHandle = &pool[*pHandle]->nextNode;
    }
    bool exists = (bool)(*pHandle);
    return {*this, pHandle, bucket, exists, key};
  }

  template <class K = Key,
            std::enable_if_t<!std::is_convertible_v<K, Entry> &&
                             !std::is_same_v<K, Entry>> * = nullptr>
  auto operator[](const K &key) {
    return this->operator[](getKey(key));
  }

  // template <class K,
  //           std::enable_if_t<std::is_same_v<
  //               std::remove_cv_t<std::remove_reference_t<K>>, Key>> * =
  //               nullptr>
  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  ConstMapAccessor operator[](const Key &key) const {
    auto accessor = const_cast<Self &>(*this)[key];
    return std::bit_cast<ConstMapAccessor>(accessor); // rvo works?
  }

  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  auto operator[](const K &key) const {
    return this->operator[](getKey(key));
  }

public:
  Iterator begin() {
    auto node =
        buckets.numItems ? buckets[0]->firstNode : GenericPoolHandle::INVALID;
    return Iterator{typename Buckets::Handle(0), node, *this};
  }
  Iterator end() {
    return Iterator{typename Buckets::Handle(buckets.numItems),
                    Pool::Handle::INVALID, *this};
  }

  ConstIterator begin() const {
    auto node =
        buckets.numItems ? buckets[0]->firstNode : Buckets::Handle::INVALID;
    return ConstIterator{Buckets::Handle(0), node, *this};
  }

  ConstIterator end() const {
    return ConstIterator{Buckets::Handle(buckets.numItems),
                         Pool::Handle::INVALID, *this};
  }

public:
  template <class NewParameter>
  using With = hashTable::Final<decltype(std::tuple_cat(
      std::declval<Parameters>(), std::declval<std::tuple<NewParameter>>()))>;

  template <class NewAllocator>
  using WithAllocator = With<parameter::Allocator<NewAllocator>>;
};

template <class Parameters>
class Final final : public Custom<Final<Parameters>, Parameters> {
  using Base = Custom<Final<Parameters>, Parameters>;
  using Base::Base;
};
} // namespace VOLTISO_NAMESPACE::hashTable
