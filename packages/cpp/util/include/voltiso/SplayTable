#pragma once

#include "voltiso/Entry"
#include "voltiso/Pool"
#include "voltiso/Splay"

#include <voltiso/ON>

namespace VOLTISO_NAMESPACE::splayTable {
template <class Final, class Parameters> class Custom;
template <class Parameters> class Final;
} // namespace VOLTISO_NAMESPACE::splayTable

namespace VOLTISO_NAMESPACE {
template <class Entry>
using SplayTable = splayTable::Final<std::tuple<parameter::Entry<Entry>>>;
} // namespace VOLTISO_NAMESPACE

namespace VOLTISO_NAMESPACE::splayTable::_ {
template <class Final, class Parameters> struct Node {
private:
  using Entry = getParameter::Type<parameter::Entry, Parameters>;
  using Allocator = getParameter::Type<parameter::Allocator, Parameters>;
  using Pool = Pool<int>::template WithAllocator<Allocator>; // need to cast
  using Handle = Pool::Handle::template WithBrand<void>;

public:
  Entry entry;
  Array<Handle, 2> children = {Handle::INVALID, Handle::INVALID};
};
} // namespace VOLTISO_NAMESPACE::splayTable::_

//

namespace VOLTISO_NAMESPACE::splayTable::_ {
template <class Final, class Parameters, bool IS_CONST> class Accessor {
protected:
  using Custom = Custom<Final, Parameters>;
  using Handle = Custom::Pool::Handle;
  using Key = Custom::Key;
  using Value = Custom::Value;

protected: // public ??
  // const Key &key;
  const Custom &splayTable;
  const Handle &handle;

public:
  const bool exists;

private:
  const Custom &_splayTable() const { return splayTable; }
  Custom &_splayTable()
    requires(!IS_CONST)
  {
    return const_cast<Custom &>(splayTable);
  }

  auto &_pool() const { return splayTable.pool; }
  auto &_pool()
    requires(!IS_CONST)
  {
    return _splayTable().pool;
  }

protected:
  friend Custom;
  Accessor(const Custom &splayTable, const auto &handle)
      : splayTable(splayTable), handle(handle),
        exists(handle != Handle::INVALID) {}

public:
  const Value &value() const {
    CHECK(this->exists);
    return getValue(this->_pool()[this->splayTable.root]->entry);
  }

  Value &value() {
    CHECK(this->exists);
    return getValue(this->_pool()[this->splayTable.root]->entry);
  }

public:
  operator const Value &() const { return this->value(); }
  operator Value &()
    requires(!IS_CONST)
  {
    return this->value();
  }

  const Value &operator*() const { return this->value(); }
  Value &operator*()
    requires(!IS_CONST)
  {
    return this->value();
  }

  const Value *operator->() const { return &this->value(); }
  Value *operator->()
    requires(!IS_CONST)
  {
    return &this->value();
  }

  const Value *operator&() const { return &this->value(); }
  Value *operator&()
    requires(!IS_CONST)
  {
    return &this->value();
  }

public:
  void erase()
    requires(!IS_CONST)
  {
    CHECK(this->exists);
    auto &root = const_cast<Custom::Pool::Handle &>(this->splayTable.root);
    this->splayTable._splay()(root).erase(this->handle);
  }

  void maybeErase()
    requires(!IS_CONST)
  {
    maybeEraseLikely();
  }

  void maybeEraseLikely()
    requires(!IS_CONST)
  {
    if (this->exists) [[likely]] {
      erase();
    }
  }

  void maybeEraseUnlikely()
    requires(!IS_CONST)
  {
    if (this->exists) [[unlikely]] {
      erase();
    }
  }
};

//

template <class Final, class Parameters, bool IS_CONST>
class SetAccessor : public Accessor<Final, Parameters, IS_CONST> {
private:
  using Base = Accessor<Final, Parameters, IS_CONST>;
  using Custom = Custom<Final, Parameters>;
  using Entry = Custom::Entry;

private:
  const Entry &entry; // can be move-only

private:
  friend Custom;
  SetAccessor(const Entry &entry, const Custom &splayTable, const auto &handle)
      : Base(splayTable, handle), entry(entry) {}

public:
  auto &insert() {
    DCHECK(!this->exists);
    auto &root = const_cast<Custom::Pool::Handle &>(this->splayTable.root);
    this->splayTable._splay()(root).insert(this->entry);
    return *this;
  }

  auto &maybeInsert() { return maybeInsertLikely(); }

  auto &maybeInsertLikely() {
    if (!this->exists) [[likely]] {
      insert();
    }
    return *this;
  }

  auto &maybeInsertUnlikely() {
    if (!this->exists) [[unlikely]] {
      insert();
    }
    return *this;
  }
};

//

template <class Final, class Parameters, bool IS_CONST>
class MapAccessor : public Accessor<Final, Parameters, IS_CONST> {
private:
  using Base = Accessor<Final, Parameters, IS_CONST>;
  using Base::Base;
  using Custom = Custom<Final, Parameters>;
  using Value = Custom::Value;
  using Key = Custom::Key;

private:
  const Key &key; // can be move-only

private:
  friend Custom;
  MapAccessor(const Key &key, const Custom &splayTable, const auto &handle)
      : Base(splayTable, handle), key(key) {}

public:
  template <class... Args> auto &insert(Args &&...args) {
    CHECK(!this->exists);
    auto &root = const_cast<Custom::Pool::Handle &>(this->splayTable.root);
    this->splayTable._splay()(root).insert(
        Entry{this->key, Value(std::forward<Args>(args)...)});
    const_cast<bool &>(this->exists) = true;
    return *this;
  }

  template <class... Args> auto &maybeInsert(Args &&...args) {
    return maybeInsertLikely(std::forward<Args>(args)...);
  }

  template <class... Args> auto &maybeInsertLikely(Args &&...args) {
    if (!this->exists) [[likely]] {
      insert(std::forward<Args>(args)...);
    }
    return *this;
  }

  template <class... Args> auto &maybeInsertUnlikely(Args &&...args) {
    if (!this->exists) [[unlikely]] {
      insert(std::forward<Args>(args)...);
    }
    return *this;
  }

}; // class MapAccessor

template <class Final, class Parameters> class Iterator {
private:
  using Custom = Custom<Final, Parameters>;
  using Pool = Custom::Pool;

private:
  using Stack =
      DynamicArray<typename Pool::Handle>::template WithInPlaceOnly<32>;
  Stack stack;

private:
  Custom &splayTable;

private:
  friend Custom;
  Iterator(bool end, Custom &splayTable) : splayTable(splayTable) {
    if (!end) {
      auto current = splayTable.root;
      while (current) {
        stack.push(current);
        current = splayTable.pool[current]->children[0];
      }
    }
  }

public:
  void operator++() {
    GT(stack.numItems, 0);
    auto &pool = splayTable.pool;
    auto current = stack.last();
    if (pool[current]->children[1]) {
      current = pool[current]->children[1];
      stack.push(current);
      while (pool[current]->children[0]) {
        current = pool[current]->children[0];
        stack.push(current);
      }
    } else {
      do {
        current = stack.pop();
      } while (stack.numItems && pool[stack.last()]->children[1] == current);
    }
  }

  // ! only for `for auto`
  bool operator==(const Iterator &other) const {
    return stack.numItems == other.stack.numItems;
  }

  auto &operator*() const { return splayTable.pool[stack.last()]->entry; }
}; // class Iterator

} // namespace VOLTISO_NAMESPACE::splayTable::_

//

namespace VOLTISO_NAMESPACE::splayTable {
template <class Final, class Parameters> class Custom : public Object<Final> {
  using Self = Custom;

public:
  using Entry = getParameter::Type<parameter::Entry, Parameters>;
  using Key = GetKey<Entry>;
  using Value = GetValue<Entry>;
  using Allocator = getParameter::Type<parameter::Allocator, Parameters>;

  // using ConstAccessor = _::ConstAccessor<Final, Parameters>;
  using SetAccessor = _::SetAccessor<Final, Parameters, false>;
  using ConstSetAccessor = _::SetAccessor<Final, Parameters, true>;

  using MapAccessor = _::MapAccessor<Final, Parameters, false>;
  using ConstMapAccessor = _::MapAccessor<Final, Parameters, true>;

  friend SetAccessor;
  friend MapAccessor;
  friend ConstSetAccessor;
  friend ConstMapAccessor;
  friend _::Accessor<Final, Parameters, false>;
  friend _::Accessor<Final, Parameters, true>;

  // using ConstIterator = ConstIterator<Options>;
  using Iterator = _::Iterator<Final, Parameters>;
  friend Iterator;

private:
  using Node = _::Node<Final, Parameters>;
  using Pool = Pool<Node>::template WithAllocator<Allocator>;

private:
  Pool pool;
  Pool::Handle root = Pool::Handle::INVALID;

public:
  ~Custom() { _destroy(root); }

private:
  void _destroy(Pool::Handle node) {
    if (!node) [[likely]] // optimize empty splay path (fast)
      return;

    DynamicArray<typename Pool::Handle> stack = {node};
    while (stack.numItems) {
      auto node = stack.pop();

      if (node->children[0]) [[likely]]
        stack.push(node->children[0]);

      if (node->children[1]) [[likely]]
        stack.push(node->children[1]);

      pool.erase(node);
    }
  }
  // // non-stack-overflow friendly
  // void _destroy(Pool::Handle node) {
  //   if (!node)
  //     return;

  //   _destroy(node->children[0]);
  //   _destroy(node->children[1]);
  //   pool.erase(node);
  // }

public:
  Custom() = default;
  Custom(std::initializer_list<Entry> entries) {
    for (auto &entry : entries) {
      insert(entry);
    }
  }

  template <class... Args>
    requires std::is_constructible_v<Entry, Args...>
  void insert(Args &&...args) {
    // construct only once, so that we can get key
    auto entry = Entry(std::forward<Args>(args)...);
    insert(std::move(entry));
  }

  template <class TEntry>
    requires std::is_same_v<Entry, std::decay_t<TEntry>>
  void insert(TEntry &&entry) {
#if VOLTISO_DEBUG_SPLAY
    auto &key = getKey(entry);
    auto handle = _splay()(root).find(key);
    bool exists = handle != Pool::Handle::INVALID;
    CHECK(!exists);
#endif
    // auto &root = const_cast<Pool::Handle &>(this->root);
    auto newHandle = _splay()(root).insert(std::forward<TEntry>(entry));
    EQ(newHandle, root);
  }

  template <class TEntry>
    requires std::is_constructible_v<Entry, TEntry>
  void maybeInsert(TEntry &&entry) {
    maybeInsertLikely(std::forward<TEntry>(entry));
  }

  template <class TEntry>
    requires std::is_constructible_v<Entry, TEntry>
  void maybeInsertLikely(TEntry &&entry) {
    auto &key = getKey(entry);
    auto handle = _splay()(root).find(key);
    bool exists = handle != Pool::Handle::INVALID;
    if (!exists) [[likely]] {
      insert(std::forward<TEntry>(entry));
    }
  }

  template <class TEntry>
    requires std::is_constructible_v<Entry, TEntry>
  void maybeInsertUnlikely(TEntry &&entry) {
    auto &key = getKey(entry);
    auto handle = _splay()(root).find(key);
    bool exists = handle != Pool::Handle::INVALID;
    if (!exists) [[unlikely]] {
      insert(std::forward<TEntry>(entry));
    }
  }

private:
  auto _splay() const {
    auto &pool = const_cast<Pool &>(this->pool);
    return Splay<Pool>(pool);
  }

public:
  SetAccessor operator[](const Entry &entry) {
    auto splay = this->_splay();
    auto handle = splay(this->root).find(getKey(entry));
    return SetAccessor{entry, *this, handle};
  }

  ConstSetAccessor operator[](const Entry &entry) const {
    auto splay = this->_splay();
    auto handle = splay(this->root).find(getKey(entry));
    return ConstSetAccessor{entry, *this, handle};
  }

  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  MapAccessor operator[](const Key &key) {
    auto splay = this->_splay();
    auto handle = splay(this->root).find(key);
    return MapAccessor{key, *this, handle};
  }

  template <class K = Key,
            std::enable_if_t<!std::is_same_v<K, Entry>> * = nullptr>
  ConstMapAccessor operator[](const Key &key) const {
    auto splay = this->_splay();
    auto handle = splay(this->root).find(key);
    return ConstMapAccessor{key, *this, handle};
  }

public:
  Iterator begin() { return Iterator(false, *this); }
  Iterator end() { return Iterator(true, *this); }
}; // class Custom

template <class Parameters>
class Final final : public Custom<Final<Parameters>, Parameters> {
  using Base = Custom<Final<Parameters>, Parameters>;
  using Base::Base;
}; // class Final

} // namespace VOLTISO_NAMESPACE::splayTable

#include <voltiso/OFF>
