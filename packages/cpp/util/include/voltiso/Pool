#pragma once
#include <voltiso/_>

#include "voltiso/DynamicArray"
#include "voltiso/Handle"
#include "voltiso/concepts/Options"
#include "voltiso/option"

#include <voltiso/ON>

#ifndef VOLTISO_DEBUG_POOL
#define VOLTISO_DEBUG_POOL VOLTISO_DEBUG
#endif

namespace VOLTISO_NAMESPACE {

// forward declarations
namespace pool {
template <class Final, class Options>
  requires concepts::Options<Options>
class Custom;

template <class Options>
  requires concepts::Options<Options>
class Final final : public Custom<Final<Options>, Options> {
  using Base = Custom<Final<Options>, Options>;
  using Base::Base;
};
} // namespace pool

//

namespace pool::_ {
template <class Item> struct Slot {
  union {
    Storage<Item> storage;
    Slot *next; // must be zero-filled manually
  };

  //   template <class... Args> Slot(Args &&...args) {
  //     storage.construct(std::forward<Args>(args)...);
  //   }
};

template <class Options> struct Block {
  using Item = Options::template Get<option::Item>;
  using Allocator = Options::template Get<option::Allocator>;

  Slot<Item> *allocationStart;
  Slot<Item> *allocationEnd;

  //   static_assert(is_trivially_relocatable<decltype(numBytes)>);
  //   static_assert(is_trivially_relocatable<decltype(allocation)>);

  Block(size_t numItems) {
    auto numBytes = numItems * sizeof(Slot<Item>);
    auto handle = Singleton<Allocator>::instance().allocateBytes(numBytes);
    static_assert(sizeof(Slot<Item> *) == sizeof(handle));
    this->allocationStart = std::bit_cast<Slot<Item> *>(handle);
    this->allocationEnd = this->allocationStart + numItems;
    std::memset((void *)this->allocationStart, 0, numBytes);
  }

  Block(const Block &) = delete;
  Block &operator=(const Block &) = delete;

  ~Block() {
    auto numBytes = (std::byte *)allocationEnd - (std::byte *)allocationStart;
    Singleton<Allocator>::instance().freeBytes(
        typename Allocator::Handle(allocationStart), numBytes);
  }
};
} // namespace pool::_

template <class Options>
static constexpr auto is_trivially_relocatable<pool::_::Block<Options>> = true;

//

namespace pool {
template <class Final, class Options, bool IS_CONST> class Accessor {
  using Pool = Custom<Final, Options>;
  using MaybeConstPool = std::conditional_t<IS_CONST, const Pool, Pool>;

  using Item = typename Pool::Item;
  using MaybeConstItem = std::conditional_t<IS_CONST, const Item, Item>;

  using Handle = typename Pool::Handle;

  static_assert(std::is_same_v<typename Handle::Type, Item *>);

public:
  const Handle handle;
  //   _::Slot<MaybeConstItem> *slot;

private:
  MaybeConstPool &pool;

private:
  friend Pool;
  Accessor(MaybeConstPool &pool, const Handle &handle) noexcept
      : handle(handle), pool(pool) {}

  Accessor(MaybeConstPool &pool, _::Slot<MaybeConstItem> *slot) noexcept
      : handle(slot), pool(pool) {}

  Accessor(const Accessor &) = delete;
  Accessor &operator=(const Accessor &) = delete;

public:
  MaybeConstItem &item() noexcept {
    return *std::bit_cast<MaybeConstItem *>(handle);
  }
  const Item &item() const noexcept {
    return *std::bit_cast<const Item *>(handle);
  }

  MaybeConstItem &operator*() noexcept { return item(); }
  const Item &operator*() const noexcept { return item(); }

  MaybeConstItem *operator->() noexcept { return &item(); }
  const Item *operator->() const noexcept { return &item(); }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  operator Item &() noexcept {
    return item();
  }

  operator const Item &() const noexcept { return item(); }

  operator Handle() const noexcept { return handle; }
  explicit operator bool() const noexcept { return (bool)handle; }

  template <bool C = IS_CONST, std::enable_if_t<!C> * = nullptr>
  void erase() const {
    pool.erase(handle);
  }
};
} // namespace pool

//

namespace pool {

// Current implementation does not ever release memory to the system.
// In the future, it's possible to keep free-lists per block, but additional
// indirection would make things a little bit slower.
template <class Final, class Options>
  requires concepts::Options<Options>
class Custom : public Singleton<
                   typename Options::template Get<option::Allocator>>::Guard {
  //   static_assert(std::is_base_of_v<Custom, Final>);

public:
  using Item = Options::template Get<option::Item>;
  static_assert(!std::is_reference_v<Item>);
  static_assert(!std::is_const_v<Item>);
  static_assert(!std::is_volatile_v<Item>);

  using Allocator = Options::template Get<option::Allocator>;

  using Handle = Handle ::WithType<Item *>::template WithBrand<Final>;

  using Accessor = pool::Accessor<Final, Options, false>;
  using ConstAccessor = pool::Accessor<Final, Options, true>;

  static_assert(std::is_same_v<typename Handle::Type, Item *>);

private:
  using Slot = _::Slot<Item>;

private:
  DynamicArray<_::Block<Options>> blocks;
  Slot *anyFreeSlot = nullptr;

  // below values could be read from last block instead
  Slot *remainingStart = nullptr;
  Slot *remainingEnd = nullptr;

  size_t numSlots = 0;

  friend Accessor;
  friend ConstAccessor;

#if VOLTISO_DEBUG_POOL
public:
  ~Custom() {
    std::cout << "DESTROYING POOL " << demangle(typeid(decltype(*this)))
              << std::endl;
    size_t numSlotsInChain = 0;
    auto nextSlot = anyFreeSlot;
    while (nextSlot) {
      ++numSlotsInChain;
      nextSlot = nextSlot->next;
    }
    auto numSlotsInLastBlock = remainingEnd - remainingStart;
    EQ(numSlotsInChain + numSlotsInLastBlock, numSlots);
  }
#endif

public:
  ConstAccessor operator[](Handle handle) const noexcept {
    return ConstAccessor(*this, handle);
  }

  Accessor operator[](Handle handle) noexcept {
    return Accessor(*this, handle);
  }

  template <class... Args> Accessor insert(Args &&...args) {
    if (anyFreeSlot) [[likely]] {
      auto slot = anyFreeSlot;
      anyFreeSlot = anyFreeSlot->next;
      new (&slot->storage) Item(std::forward<Args>(args)...);
      return Accessor(*this, slot);
    } else if (remainingStart != remainingEnd) [[likely]] {
      auto slot = remainingStart;
      ++remainingStart;
      new (&slot->storage) Item(std::forward<Args>(args)...);
      return Accessor(*this, slot);
    } else [[unlikely]] {
      auto numNewSlots = numSlots + 1;
      GE(numNewSlots, 1);
      blocks.push(numNewSlots);
      numSlots += numNewSlots;
      remainingStart = blocks.last().allocationStart;
      remainingEnd = blocks.last().allocationEnd;
      auto slot = remainingStart;
      ++remainingStart;
      new (&slot->storage) Item(std::forward<Args>(args)...);
      return Accessor(*this, slot);
    }
  }

  auto insert(const Item &item) { return insert<>(item); }
  auto insert(Item &&item) { return insert<>(std::move(item)); }

  void erase(const Handle &handle) noexcept {
    CHECK(handle);
    auto slot = std::bit_cast<_::Slot<Item> *>(handle);
    static_assert(sizeof(slot) == sizeof(Handle));
    slot->storage.destroy();
    slot->next = this->anyFreeSlot;
    this->anyFreeSlot = slot;
  }

private:
  auto &allocator() const { return Allocator::instance(); }

public:
  template <class Option>
  using With = pool::Final<typename Options::template With<Option>>;

  template <class Item> using WithItem = With<option::Item<Item>>;

  template <class Allocator>
  using WithAllocator = With<option::Allocator<Allocator>>;
}; // class Custom
} // namespace pool

template <class Item>
class Pool final
    : public pool::Custom<Pool<Item>, Options<option::Item<Item>>> {
  using Base = pool::Custom<Pool<Item>, Options<option::Item<Item>>>;
  using Base::Base;
};

} // namespace VOLTISO_NAMESPACE

#include <voltiso/OFF>
